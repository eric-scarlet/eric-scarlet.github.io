<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="第九章 虚拟内存管理9.1背景 虚拟内存将用户逻辑内存与物理内存分开，虚拟内存使得编程更容易  虚拟地址空间就是进程如何在内存中存放的逻辑，通常进程从某一逻辑地址开始，连续存放：     根据第八章所述，物理地址可以按帧来组织，并且分配给进程的物理帧也可以不连续。从而需要内存管理单元（MMU）将逻辑页映射到内存的物理页帧。  虚拟内存大于物理内存的图例：  虚拟存储器的特征 多次性：最重要的特征一">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟内存管理">
<meta property="og:url" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="第九章 虚拟内存管理9.1背景 虚拟内存将用户逻辑内存与物理内存分开，虚拟内存使得编程更容易  虚拟地址空间就是进程如何在内存中存放的逻辑，通常进程从某一逻辑地址开始，连续存放：     根据第八章所述，物理地址可以按帧来组织，并且分配给进程的物理帧也可以不连续。从而需要内存管理单元（MMU）将逻辑页映射到内存的物理页帧。  虚拟内存大于物理内存的图例：  虚拟存储器的特征 多次性：最重要的特征一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201120204337532.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201120204540568.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201120210259800.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121134918903.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121140141132.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121140306794.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121141402897.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121144049828.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121144058267.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121160704219.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121161304859.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121162716728.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121162727420.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163336874.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163442167.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163449651.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163711889.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121165125824.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121165331407.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121165402585.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121170629101.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122110555185.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122113234216.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122115629343.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122145251540.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122145733309.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122150151647.png">
<meta property="og:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122151605316.png">
<meta property="article:published_time" content="2020-11-20T12:37:21.000Z">
<meta property="article:modified_time" content="2020-11-22T07:17:52.803Z">
<meta property="article:author" content="eric-scarlet">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201120204337532.png">


<link rel="canonical" href="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>虚拟内存管理 | blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">第九章 虚拟内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">9.1背景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">1.1.1.</span> <span class="nav-text">虚拟存储器的特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB"><span class="nav-number">1.1.2.</span> <span class="nav-text">共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E7%B2%97%E4%B8%BA%E4%B9%A6%E4%B8%8A%EF%BC%9A%EF%BC%88%E4%BB%A5%E4%B8%8B%E5%A4%A7%E9%83%A8%E5%88%86%E4%B8%BA%E4%B9%A6%E4%B8%8A%E4%B8%8EPPT%E7%9B%B8%E7%BB%93%E5%90%88%E5%B9%B6%E5%81%9A%E5%BF%85%E8%A6%81%E4%BF%AE%E6%94%B9%EF%BC%89"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">加粗为书上：（以下大部分为书上与PPT相结合并做必要修改）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PPT%EF%BC%9A"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">PPT：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5"><span class="nav-number">1.2.</span> <span class="nav-text">9.2请求调页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.1.</span> <span class="nav-text">9.2.1基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">修改后的页表机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E6%95%85%E9%9A%9C%EF%BC%88%E9%94%99%E8%AF%AF%EF%BC%89"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">缺页故障（错误）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E6%95%85%E9%9A%9C%EF%BC%88%E9%94%99%E8%AF%AF%EF%BC%89%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">缺页故障（错误）处理方式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">地址翻译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E6%89%A7%E8%A1%8C"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">恢复执行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-2%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">1.2.2.</span> <span class="nav-text">9.2.2请求调页的性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">提高性能的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">9.3写时复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">1.4.</span> <span class="nav-text">9.4页面置换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-1%E5%9F%BA%E6%9C%AC%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">1.4.1.</span> <span class="nav-text">9.4.1基本页面置换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-2FIFO%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">1.4.2.</span> <span class="nav-text">9.4.2FIFO页面置换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-3%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">1.4.3.</span> <span class="nav-text">9.4.3最优页面置换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-4LRU%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">1.4.4.</span> <span class="nav-text">9.4.4LRU页面置换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-5%E8%BF%91%E4%BC%BCLRU%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">1.4.5.</span> <span class="nav-text">9.4.5近似LRU页面置换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-5-1%E9%A2%9D%E5%A4%96%E5%BC%95%E7%94%A8%E4%BD%8D%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">9.4.5.1额外引用位算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-5-2%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">9.4.5.2第二次机会算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-5-3%E5%A2%9E%E5%BC%BA%E5%9E%8B%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">9.4.5.3增强型第二次机会算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-6%E5%9F%BA%E4%BA%8E%E8%AE%A1%E6%95%B0%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">1.4.6.</span> <span class="nav-text">9.4.6基于计数的页面置换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-7%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%86%B2%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">9.4.7页面缓冲算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">9.4.8应用程序与页面置换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5%E5%B8%A7%E5%88%86%E9%85%8D"><span class="nav-number">1.5.</span> <span class="nav-text">9.5帧分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5-1%E5%B8%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0"><span class="nav-number">1.5.1.</span> <span class="nav-text">9.5.1帧的最小数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5-2%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.2.</span> <span class="nav-text">9.5.2分配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8D"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">平均分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E4%BE%8B%E5%88%86%E9%85%8D"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">比例分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E9%85%8D"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">优先级分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5-3%E5%85%A8%E5%B1%80%E5%88%86%E9%85%8D%E4%B8%8E%E5%B1%80%E9%83%A8%E5%88%86%E9%85%8D"><span class="nav-number">1.5.3.</span> <span class="nav-text">9.5.3全局分配与局部分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6%E7%B3%BB%E7%BB%9F%E6%8A%96%E5%8A%A8"><span class="nav-number">1.6.</span> <span class="nav-text">9.6系统抖动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6-1%E7%B3%BB%E7%BB%9F%E6%8A%96%E5%8A%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.6.1.</span> <span class="nav-text">9.6.1系统抖动的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6-2%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.6.2.</span> <span class="nav-text">9.6.2工作集模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6-3%E7%BC%BA%E9%A1%B5%E9%94%99%E8%AF%AF%E9%A2%91%E7%8E%87"><span class="nav-number">1.6.3.</span> <span class="nav-text">9.6.3缺页错误频率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-8%E5%88%86%E9%85%8D%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98"><span class="nav-number">1.7.</span> <span class="nav-text">9.8分配内核内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-8-1%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.7.1.</span> <span class="nav-text">9.8.1伙伴系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-8-2slab%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">1.7.2.</span> <span class="nav-text">9.8.2slab分配器</span></a></li></ol></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="eric-scarlet"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">eric-scarlet</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="eric-scarlet">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          虚拟内存管理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-20 20:37:21" itemprop="dateCreated datePublished" datetime="2020-11-20T20:37:21+08:00">2020-11-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-22 15:17:52" itemprop="dateModified" datetime="2020-11-22T15:17:52+08:00">2020-11-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="第九章-虚拟内存管理"><a href="#第九章-虚拟内存管理" class="headerlink" title="第九章 虚拟内存管理"></a>第九章 虚拟内存管理</h1><h2 id="9-1背景"><a href="#9-1背景" class="headerlink" title="9.1背景"></a>9.1背景</h2><ul>
<li><p><strong>虚拟内存</strong>将用户逻辑内存与物理内存分开，虚拟内存使得编程更容易</p>
</li>
<li><p><strong>虚拟地址空间</strong>就是进程如何在内存中存放的逻辑，通常进程从某一逻辑地址开始，连续存放：</p>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201120204337532.png" alt="image-20201120204337532"></p>
<ul>
<li>根据第八章所述，物理地址可以按帧来组织，并且分配给进程的物理帧也可以不连续。从而需要内存管理单元（MMU）将逻辑页映射到内存的物理页帧。</li>
</ul>
<p>虚拟内存大于物理内存的图例：</p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201120204540568.png" alt="image-20201120204540568"></p>
<h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><ul>
<li><p>多次性：最重要的特征<br>一个作业被分成多次装入内存运行</p>
</li>
<li><p>对换性<br>允许在进程运行的过程中，（部分）换入换出</p>
</li>
<li><p>虚拟性<br>逻辑上的扩充</p>
</li>
<li><p>虚拟性是以多次性和对换性为基础的。</p>
</li>
<li><p>多次性和对换性是建立在离散分配的基础上的</p>
</li>
</ul>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><h4 id="加粗为书上：（以下大部分为书上与PPT相结合并做必要修改）"><a href="#加粗为书上：（以下大部分为书上与PPT相结合并做必要修改）" class="headerlink" title="加粗为书上：（以下大部分为书上与PPT相结合并做必要修改）"></a>加粗为书上：（以下大部分为书上与PPT相结合并做必要修改）</h4><p><strong>虚拟内存允许文件和内存通过共享页而为多个进程所共享，带来以下好处：</strong></p>
<ul>
<li><strong>通过将共享对象映射到虚拟地址空间中，系统库可以为多个进程所共享。</strong></li>
<li><strong>类似的，虚拟内存允许进程共享内存。</strong></li>
<li><strong>当通过系统调用创建进程时，可以共享页面，从而加快进程创建。</strong></li>
</ul>
<h4 id="PPT："><a href="#PPT：" class="headerlink" title="PPT："></a>PPT：</h4><ul>
<li><p>一些好处：</p>
</li>
<li><p>共享内存</p>
</li>
<li><p>加快流程创建</p>
</li>
<li><p>程序员无需关心内存限制</p>
</li>
<li><p>可以同时运行更多程序</p>
</li>
<li><p>所需的I / O更少，每个用户程序将运行得更快</p>
</li>
<li><p>共享库使用</p>
</li>
<li><p>虚拟内存</p>
</li>
</ul>
<h2 id="9-2请求调页"><a href="#9-2请求调页" class="headerlink" title="9.2请求调页"></a>9.2请求调页</h2><ul>
<li><p>仅在需要时才加载页面——请求调页，常用于虚拟内存系统</p>
<ul>
<li>所需的I / O更少</li>
<li>需要更少的内存</li>
<li>更快的反应</li>
<li>更多用户</li>
</ul>
</li>
<li><p>当一个页面被需要时才指向它（？）如果是不合法的指代则抛弃，如果未在内存中，则在内存中加载之。</p>
</li>
</ul>
<p><strong>交换器 VS 调页程序</strong></p>
<ul>
<li>交换器可操纵整个过程</li>
<li>惰性交换器<ul>
<li>除非需要页面，否则切勿将页面交换到内存中</li>
<li>处理单个页面的交换器是寻呼机<img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201120210259800.png" alt="image-20201120210259800"></li>
</ul>
</li>
</ul>
<h3 id="9-2-1基本概念"><a href="#9-2-1基本概念" class="headerlink" title="9.2.1基本概念"></a>9.2.1基本概念</h3><ul>
<li>修改后的页表机制</li>
<li>缺页故障/缺页错误</li>
<li>地址翻译</li>
<li>辅助内存（作为交换空间）</li>
</ul>
<h4 id="修改后的页表机制"><a href="#修改后的页表机制" class="headerlink" title="修改后的页表机制"></a>修改后的页表机制</h4><ul>
<li><p>有效无效位（PRESENT位）</p>
<ul>
<li><p>每个页表条目都与一个有效-无效位相关联<br>v ⇒ 在内存中并且合法，<br>i ⇒ 不在内存中</p>
</li>
<li><p>开始时，将有效-无效位全部设置为i<br>在地址转换期间，如果页表项中的有效无效位是i⇒页面错误</p>
</li>
</ul>
</li>
<li><p>参考位（用于寻呼机输出）</p>
</li>
<li><p>修改位（或脏位）</p>
</li>
<li><p>辅助存储信息（用于分页器）</p>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121134918903.png" alt="image-20201121134918903"></p>
<h4 id="缺页故障（错误）"><a href="#缺页故障（错误）" class="headerlink" title="缺页故障（错误）"></a>缺页故障（错误）</h4><p><strong>对标记为无效的页面访问会产生缺页错误。分页硬件在通过页表转换地址时会注意到无效位被设置，从而陷入操作系统。这种陷阱是操作系统未能将所需的页面调入内存引起的。</strong></p>
<ul>
<li>第一次引用页面将捕获到OS：<br>页面错误（缺页故障/异常/中断）</li>
<li>缺页异常<ul>
<li>精确异常（陷阱）<br>在完全相同的位置和状态下重新启动该过程。<br>重新执行触发陷阱的指令</li>
</ul>
</li>
<li>执行一条指令可能会导致多页错误</li>
<li>页面错误可能在每个内存引用处发生</li>
<li>一条指令在获取指令或读/写操作符时可能导致多页错误</li>
</ul>
<h4 id="缺页故障（错误）处理方式："><a href="#缺页故障（错误）处理方式：" class="headerlink" title="缺页故障（错误）处理方式："></a>缺页故障（错误）处理方式：</h4><ul>
<li>操作系统查看内部表来决定：<br>如果是无效的参考 ⇒ 中止<br>如果只是不在内存中 ⇒ 带到内存中</li>
<li>找到一个空闲帧（例如从空闲帧链表上得到一个）    </li>
<li>调度一个磁盘操作，以将所需页面读到刚分配的帧</li>
<li>修改内部表并设置验证位 = v</li>
<li>重新启动被陷阱中断的指令</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121140141132.png" alt="image-20201121140141132"></p>
<p>上图：缺页错误处理图示</p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121140306794.png" alt="image-20201121140306794"></p>
<p><strong>纯请求调页：只有在需要时才将页面调入内存。</strong></p>
<p><strong>支持请求调页的硬件与分页和交换的硬件相同：</strong></p>
<p><strong>页表：能通过有效-无效位或保护位的特定值将条目标记为无效</strong></p>
<p><strong>外存（辅助存储）：用于保护不在内存（主存）中的那些页面。</strong></p>
<p><strong>请求调页的关键要求是在缺页错误后重新启动任何指令的能力。因为当发生缺页错误时，保存了被中断的进程状态（寄存器，条件代码，指令计数器），所以应能够在完全相同的状态下重新启动进程，只不过现在所需的页面已在内存中并且是可以访问的。</strong></p>
<ul>
<li><p>重新启动指令<br>C = A + B</p>
<ul>
<li>1.取指令</li>
<li>2.取得A</li>
<li>3.取得B</li>
<li>4.添加A和B</li>
<li>5.将总和存储在C中（C不在内存中）</li>
</ul>
</li>
<li><p>问题可以忽略</p>
<ul>
<li>重复</li>
<li>1条指令导致N页错误</li>
</ul>
</li>
</ul>
<h4 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h4><p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121141402897.png" alt="image-20201121141402897"></p>
<h4 id="恢复执行"><a href="#恢复执行" class="headerlink" title="恢复执行"></a>恢复执行</h4><ul>
<li>保存现场<br>在操作系统处理页面错误之前，必须保存进程状态<pre><code>示例：记录其寄存器值，PC</code></pre>
</li>
<li>恢复现场<br>保存状态允许该过程从中断的行继续进行。</li>
<li>注意：区分以下两种情况<ul>
<li>非法引用⇒处理终止</li>
<li>页面错误⇒装入或传呼</li>
</ul>
</li>
</ul>
<h3 id="9-2-2请求调页的性能"><a href="#9-2-2请求调页的性能" class="headerlink" title="9.2.2请求调页的性能"></a>9.2.2请求调页的性能</h3><ul>
<li>令p =页面错误率（0≤p≤1）<br>   如果p = 0，则无页面错误<br>   如果p = 1，则每个参考都是故障，完全在请求调页</li>
<li>有效访问时间（EAT）<br>EAT =（1-p）× 内存访问时间+ p × 缺页错误时间<br>缺页错误时间=缺页错误开销<br>+换出页面（可选）<br>+换入页面<br>+重新启动开销</li>
</ul>
<p><strong>12个动作见书p397</strong></p>
<ul>
<li><p>例</p>
<ul>
<li><p>内存访问时间= 200ns</p>
</li>
<li><p>平均页面错误服务时间= 8毫秒<br>EAT =（1-p）× 200 + p × 8ms =（1-p）× 200 + p × 8000000 = 200 + p×7999800</p>
</li>
<li><p>如果千分之一访问导致页面错误，则<br>p = 0.001<br>EAT = 8，199.8ns =8.2μs<br>这是8.2us / 200ns = 40倍的减速！！</p>
</li>
<li><p>如果我们希望性能下降&lt;10％，则<br>进餐= 200 + p×7，999，800 &lt;200（1 + 10％）= 220<br>p×7，999，800 &lt;20<br>p &lt;20 /7,999,800≈0.0000025</p>
</li>
</ul>
</li>
</ul>
<h4 id="提高性能的方法"><a href="#提高性能的方法" class="headerlink" title="提高性能的方法"></a>提高性能的方法</h4><ul>
<li>减少故障时间<br>-交换空间，快于文件系统<br>-仅脏页被换出，或<br>-仅从交换空间进行请求分页，或者<br>-最初要求从文件系统分页，换出到交换空间，然后从交换空间进行所有后续分页</li>
<li>保持极低的故障率<br>-程序执行本地化<br>-时间，空间</li>
</ul>
<h2 id="9-3写时复制"><a href="#9-3写时复制" class="headerlink" title="9.3写时复制"></a>9.3写时复制</h2><p><strong>虚拟内存在流程创建期间具有其他好处：</strong></p>
<ul>
<li>写时复制</li>
<li>允许父进程和子进程最初共享内存中的相同页面</li>
<li>如果任一进程修改了共享页面，则会创建共享页面的副本</li>
<li>COW允许更有效的流程创建，因为仅复制修改的页面</li>
<li>从清零页面池中分配免费页面</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121144049828.png" alt="image-20201121144049828"></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121144058267.png" alt="image-20201121144058267"></p>
<h2 id="9-4页面置换"><a href="#9-4页面置换" class="headerlink" title="9.4页面置换"></a>9.4页面置换</h2><ul>
<li>如果具有10页的进程只使用其中的一半，那么请求调页就节省了用来加载从不使用的另外5页的I/O。另外，通过运行两倍的进程，增加了多道程度，因此若有40帧那么可以运行8个进程而不是4个。</li>
<li>增加多道程度可能会导致过度分配内存，如果运行6个进程每个进程有10个页面但是仅仅使用5个，会有更高的CPU利用率和吞吐量。</li>
<li>而且还需要考虑到内存不仅用于保存程序页面，还有I/O缓存</li>
</ul>
<p>内存过度分配：用户进程执行–&gt;缺页错误–&gt;操作系统确定所需页面的磁盘位置却发现空闲帧列表上没有空闲帧—&gt;页面置换</p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121160704219.png" alt="image-20201121160704219"></p>
<p><strong>页面置换</strong><br>通过修改页面故障服务例程以包括页面替换，防止内存的过度分配。</p>
<h3 id="9-4-1基本页面置换"><a href="#9-4-1基本页面置换" class="headerlink" title="9.4.1基本页面置换"></a>9.4.1基本页面置换</h3><ul>
<li><p><strong>在磁盘上找到所需页面的位置</strong></p>
</li>
<li><p><strong>找到一个空闲帧：</strong></p>
<ul>
<li><p><strong>如果有空闲帧，那么就使用它</strong></p>
</li>
<li><p><strong>如果没有空闲帧，那么就使用页面置换算法来选择一个牺牲帧</strong></p>
</li>
<li><p><strong>将牺牲帧的内容写到磁盘上，修改对应的页表和帧表</strong></p>
</li>
</ul>
</li>
<li><p><strong>将所需页面读入新的空闲帧，修改页表和帧表</strong></p>
</li>
<li><p><strong>从发生缺页错误位置，继续用户进程</strong></p>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121161304859.png" alt="image-20201121161304859"></p>
<p><strong>（若无空闲帧，那么需要两个页面传输（调出和调入）。这种情况实际上加倍了缺页错误的处理时间，并相应的增加了有效访问时间）</strong></p>
<ul>
<li>没有修改，就没有写入（到磁盘/交换空间）<ul>
<li>使用修改（脏）位来减少页面传输的开销<br>-仅将修改的页面写入磁盘</li>
<li>此技术也适用于只读页面<br>-例如，二进制代码页</li>
</ul>
</li>
<li><strong>页面置换是请求调页的基础。它完成了逻辑内存和物理内存之间的分离</strong><ul>
<li>可以在较小的物理内存上提供大的虚拟内存</li>
</ul>
</li>
<li>按需分页，获得最低的页面错误率，两个主要问题<ul>
<li>帧分配算法——<strong>若有多个进程在内存中，则必须选择要为每个进程分配多少帧</strong></li>
<li>页面置换算法——<strong>当需要页面置换时，必须选择要置换的帧</strong></li>
</ul>
</li>
</ul>
<p><strong>有许多页面置换算法，每个操作系统可能都有自己的置换方案。通常采用最小缺页错误率的算法。</strong></p>
<ul>
<li>目标：获得最低的页面错误率</li>
<li>通过在特定的内存引用字符串（引用字符串）上运行并计算该字符串上的页面错误数来评估不同的算法</li>
<li>引用字符串是程序引用的地址序列<br>例：<ul>
<li>地址参考字符串：<br>0100 0432 0101 0612 0102 0103 0104 0101 0611 0103 0104 0101 0610 0102 0103 0104 0101 0609 0102 0105</li>
<li>假设页面大小= 100B，则其对应的页面参考字符串为：1 4 1 6 1 6 1 6 1 6 1</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121162716728.png" alt="image-20201121162716728"></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121162727420.png" alt="image-20201121162727420"></p>
<h3 id="9-4-2FIFO页面置换"><a href="#9-4-2FIFO页面置换" class="headerlink" title="9.4.2FIFO页面置换"></a>9.4.2FIFO页面置换</h3><ul>
<li><strong>最简单的页面替换算法：FIFO</strong></li>
<li><strong>FIFO页面置换算法为每个页面记录了调到内存的时间。当必须置换页面时，将选择最旧的页面</strong></li>
<li><strong>可以创建一个FIFO队列来管理所有的内存页面（无需记录确切时间）</strong><ul>
<li><strong>置换的是队列的首个页面</strong></li>
<li><strong>当需要调入页面到内存时，就将它加到队列的尾部</strong></li>
</ul>
</li>
<li><strong>示例1：15次缺页错误，12次页面置换</strong></li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163336874.png" alt="image-20201121163336874"></p>
<p><strong>Belady异常：对于有些页面置换算法随着分配帧数量的增加缺页错误率可能会增加！</strong></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163442167.png" alt="image-20201121163442167"></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163449651.png" alt="image-20201121163449651"></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163711889.png" alt="image-20201121163711889"></p>
<h3 id="9-4-3最优页面置换"><a href="#9-4-3最优页面置换" class="headerlink" title="9.4.3最优页面置换"></a>9.4.3最优页面置换</h3><ul>
<li><p><strong>简单地说：置换最长时间不会使用的页面。</strong></p>
</li>
<li><p><strong>由于需要引用串的未来知识，最优置换算法难以实现。</strong></p>
</li>
<li><p><strong>最优置换算法主要用于比较研究。</strong></p>
</li>
<li><p><strong>不会有Belady异常</strong></p>
</li>
</ul>
<h3 id="9-4-4LRU页面置换"><a href="#9-4-4LRU页面置换" class="headerlink" title="9.4.4LRU页面置换"></a>9.4.4LRU页面置换</h3><ul>
<li><p><strong>LRU——最近最少使用</strong></p>
</li>
<li><p><strong>是最优算法的一个近似</strong></p>
</li>
<li><p>使用最近的过去作为不久的将来的近似值</p>
</li>
<li><p>替换最长时间未使用的页面</p>
</li>
<li><p>对于每个页面：记录其最后一次使用的时间</p>
</li>
<li><p>替换：最旧的时间值</p>
</li>
</ul>
<p>示例1：12个页面错误，9个页面替换</p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121165125824.png" alt="image-20201121165125824"></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121165331407.png" alt="image-20201121165331407"></p>
<p><strong>LRU置换算法也不会有Belady异常</strong></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121165402585.png" alt="image-20201121165402585"></p>
<p>LRU算法的实现：</p>
<ul>
<li><p><strong>计数器：</strong>每个页表条目关联一个时间域，并为CPU添加一个逻辑时钟或计数器。<strong>每次内存引用都会递增时钟。每当进行页面引用时，时钟寄存器的内容会复制到相应页面的也秒条目的使用时间域。置换具有最小时间的页面。</strong></p>
<ul>
<li>该方案需要搜索页表以查找LRU页面而且每次内存访问都要写到内存（到页表的使用时间域）。当页表更改时（由于CPU调度），还必须保留时间。时钟溢出也要考虑。</li>
</ul>
</li>
<li><p><strong>堆栈：</strong>以双链接形式保留一堆页码。</p>
<ul>
<li><p>引用页面时：将其移到顶部</p>
</li>
<li><p>（最坏情况）需要更改6个指针</p>
</li>
<li><p>每次更新都比较费时</p>
</li>
<li><p>没有寻找替代品</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121170629101.png" alt="image-20201121170629101"></p>
<h3 id="9-4-5近似LRU页面置换"><a href="#9-4-5近似LRU页面置换" class="headerlink" title="9.4.5近似LRU页面置换"></a>9.4.5近似LRU页面置换</h3><ul>
<li><p><strong>页表内的每个条目都关联着一个引用位</strong></p>
</li>
<li><p><strong>可以通过检查引用位来确定哪些页面已被使用，哪些页面尚未使用</strong></p>
</li>
<li><p>每个页面都与一个位相关联，最初= 0</p>
</li>
<li><p>当引用页面时，该位设置为1</p>
</li>
<li><p>替换为0的那个（如果存在一个）</p>
</li>
<li><p>但是，我们不知道顺序</p>
</li>
</ul>
<h4 id="9-4-5-1额外引用位算法"><a href="#9-4-5-1额外引用位算法" class="headerlink" title="9.4.5.1额外引用位算法"></a><strong>9.4.5.1额外引用位算法</strong></h4><ul>
<li>可以为内存中的页表保存一个8位的字节</li>
<li>定时器中断定期地（如每100ms）将控制传到操作系统</li>
<li>操作系统将每个页面引用位移到其8位字节的高位，将其他位右移一位，并丢弃最低位。</li>
<li>这些8位移位寄存器包含着最近8个时间周期内的页面使用情况</li>
<li>具有11000100的历史寄存器值的页面比具有值01110111的页面更为“最近使用的”</li>
</ul>
<h4 id="9-4-5-2第二次机会算法"><a href="#9-4-5-2第二次机会算法" class="headerlink" title="9.4.5.2第二次机会算法"></a>9.4.5.2第二次机会算法</h4><ul>
<li><p>仅需1个参考位，修改后的FIFO算法</p>
</li>
<li><p>又称时钟算法</p>
<ul>
<li>首先，通过FIFO选择页面</li>
<li>如果要替换的页面（按时钟顺序）具有参考位= 0，则进行替换</li>
<li>如果要替换的页面（按时钟顺序）具有参考位= 1，则：<ul>
<li>设定参考位为0</li>
<li>将页面保留在内存中</li>
<li>按照相同规则替换下一页（按时钟顺序）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实现第二次机会算法的一种方式是采用循环队列</strong></p>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122110555185.png" alt="image-20201122110555185"></p>
<h4 id="9-4-5-3增强型第二次机会算法"><a href="#9-4-5-3增强型第二次机会算法" class="headerlink" title="9.4.5.3增强型第二次机会算法"></a>9.4.5.3增强型第二次机会算法</h4><ul>
<li><p>通过将引用位和修改位（参见9.4.1）作为有序对，可以改进二次机会算法。</p>
</li>
<li><p>4种类型：</p>
<ul>
<li>（0，0）– 最近没有使用且没有修改的页面，最佳的页面置换</li>
<li>（0，1）– 最近没有使用但修改过的页面，不太好的置换，因为在置换之前需要将页面写出</li>
<li>（1，0）– 最近使用过但没有修改的页面，可能很快再次使用</li>
<li>（1，1）– 最近使用过且修改过，可能很快再次使用，并且在置换之前需要将页面写出到磁盘</li>
</ul>
</li>
<li><p>替换非空的最低类型中的第一个页面</p>
</li>
<li><p>步骤（a）- 扫描（0，0）</p>
</li>
<li><p>步骤（b）- 扫描（0，1），并将引用位设置为0</p>
</li>
<li><p>步骤（c）- 回至步骤（a）</p>
</li>
</ul>
<p><strong>若第一位全为1则扫描一遍后将第一位置0</strong></p>
<p><strong>与时钟算法的主要区别：为那些已修改页面赋予更高级别，从而降低了所需I/O数量</strong></p>
<h3 id="9-4-6基于计数的页面置换"><a href="#9-4-6基于计数的页面置换" class="headerlink" title="9.4.6基于计数的页面置换"></a>9.4.6基于计数的页面置换</h3><p><strong>为每个页面的引用次数保存一个计数器，并且开发以下两种方案：</strong></p>
<ul>
<li><p>LFU（最不常用）算法：置换具有最少计数的页面</p>
<ul>
<li><p>问题：一个页面最初大量使用，然后从未使用，由于被大量使用，有一个大的计数，即使不再需要却仍保留在内存中</p>
</li>
<li><p>解决方案：定期将计数右移一位以降低平均使用计数</p>
</li>
</ul>
</li>
<li><p>MFU（最常用）算法：基于以下论点：具有最小计数的页面可能刚刚被引入并且尚未使用</p>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122113234216.png" alt="image-20201122113234216"></p>
<p><strong>MFU和LFU置换都不常用。这些算法的实现是昂贵的，并且它们不能很好地近似OPT算法</strong></p>
<h4 id="9-4-7页面缓冲算法"><a href="#9-4-7页面缓冲算法" class="headerlink" title="9.4.7页面缓冲算法"></a>9.4.7页面缓冲算法</h4><ul>
<li>系统通常保留一个空闲帧缓冲池</li>
<li>当出现缺页错误时，会像以前一样选择一个牺牲帧</li>
<li>然而，在写出牺牲帧之前，所需页面就读到来自缓冲池的空闲帧</li>
<li><strong>这种措施允许进程尽快重新启动，而无需等待写出牺牲帧</strong></li>
<li>牺牲帧以后被写出后，它被添加到空闲帧池</li>
</ul>
<h4 id="9-4-8应用程序与页面置换"><a href="#9-4-8应用程序与页面置换" class="headerlink" title="9.4.8应用程序与页面置换"></a>9.4.8应用程序与页面置换</h4><ul>
<li>有的操作系统允许特殊程序能够将磁盘分区作为逻辑块的打的数组（<strong>原始磁盘</strong>）来使用，而不需要通过文件系统的数据结构。</li>
</ul>
<h2 id="9-5帧分配"><a href="#9-5帧分配" class="headerlink" title="9.5帧分配"></a>9.5帧分配</h2><h3 id="9-5-1帧的最小数"><a href="#9-5-1帧的最小数" class="headerlink" title="9.5.1帧的最小数"></a>9.5.1帧的最小数</h3><p><strong>帧分配策略受到多方面的限制——所分配的帧不能超过可用帧的数量（除非所有页面共享），也必须分配至少数量的帧。</strong></p>
<p><strong>分配至少最小数量的帧的一个原因涉及性能。随着分配给每个进程的帧数量的减少，缺页错误率增加，从而减慢进程执行。此外，若在执行指令完成之前发生缺页错误，应重新启动指令。因此必须有足够的帧来容纳任何单个指令可以引用的所有不同的页面。</strong></p>
<p><strong>最小化帧的个数</strong></p>
<ul>
<li><p>每个过程需要最少的页面数</p>
</li>
<li><p>由ISA（指令集体系结构）确定</p>
<ul>
<li>我们必须有足够的帧来容纳任何一条指令都可以引用的所有不同页面</li>
</ul>
</li>
<li><p>示例：IBM 370<br>6页处理MOVC指令：<br>   指令为6个字节，可能跨越2页<br>   2页处理<br>   2页处理</p>
</li>
<li><p>两种主要的分配方案<br>   固定分配； 优先分配</p>
</li>
<li><p>两种页面置换算法</p>
<p><strong>全局置换</strong>和<strong>局部置换</strong></p>
</li>
</ul>
<h3 id="9-5-2分配算法"><a href="#9-5-2分配算法" class="headerlink" title="9.5.2分配算法"></a>9.5.2分配算法</h3><h4 id="平均分配"><a href="#平均分配" class="headerlink" title="平均分配"></a>平均分配</h4><p>在n个进程中分配m个帧的最容易方法是，给每个进程一个平均值，即m/n帧（忽略操作系统所需的帧）。eg：93个帧，5个进程，每个进程18帧，剩余3个可用作空闲帧缓冲池。</p>
<h4 id="比例分配"><a href="#比例分配" class="headerlink" title="比例分配"></a>比例分配</h4><p>根据每个进程大小分配可用内存</p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122115629343.png" alt="image-20201122115629343"></p>
<h4 id="优先级分配"><a href="#优先级分配" class="headerlink" title="优先级分配"></a>优先级分配</h4><ul>
<li><p>使用优先级而非大小的比例分配方案</p>
</li>
<li><p>如果进程 Pi 产生页面错误，</p>
<ul>
<li><p>选择替换其框架之一</p>
</li>
<li><p>从优先级较低的进程中选择替换帧</p>
</li>
</ul>
</li>
</ul>
<h3 id="9-5-3全局分配与局部分配"><a href="#9-5-3全局分配与局部分配" class="headerlink" title="9.5.3全局分配与局部分配"></a>9.5.3全局分配与局部分配</h3><ul>
<li>全局置换<ul>
<li>允许一个进程从所有帧的集合中选择一个置换帧； 一个进程可以取下另一个帧</li>
<li>问题：进程无法控制其自身的页面错误率</li>
</ul>
</li>
<li>局部置换<ul>
<li>每个进程仅从自己分配的帧中选择一个帧</li>
<li>问题：由于不能使用其他进程较少使用的内存页面，可能会阻碍一个进程</li>
</ul>
</li>
</ul>
<h2 id="9-6系统抖动"><a href="#9-6系统抖动" class="headerlink" title="9.6系统抖动"></a>9.6系统抖动</h2><ul>
<li><p>如果某个进程没有“足够”的页面，则页面错误率非常高。 这将导致：</p>
<ul>
<li>低CPU利用率</li>
<li>OS认为它需要提高多道程序的程度</li>
<li>另一个过程被添加到系统中，变得越来越糟！</li>
</ul>
</li>
<li><p>抖动：一个进程正在忙于换入和换出页面</p>
<ul>
<li>花费比执行更多的时间</li>
</ul>
</li>
</ul>
<p><strong>阻塞的进程大大增加，就绪的进程大大减少</strong></p>
<h3 id="9-6-1系统抖动的原因"><a href="#9-6-1系统抖动的原因" class="headerlink" title="9.6.1系统抖动的原因"></a>9.6.1系统抖动的原因</h3><p><strong>不合理的多道程序程度</strong></p>
<p><strong>如何限制抖动的影响</strong></p>
<ul>
<li><p>局部置换算法？ 尚未完全解决。</p>
</li>
<li><p><strong>为了防止抖动，应为进程提供足够多的所需帧数。</strong></p>
</li>
<li><p>我们如何知道需要多少帧？</p>
</li>
<li><p><strong>工作集策略研究一个进程实际使用多少帧。这种方法定义了进程执行的局部性模型。</strong></p>
</li>
</ul>
<p><strong>局部性模型：这就是需求分页有效的原因</strong></p>
<ul>
<li>流程从一个地方迁移到另一个地方</li>
<li>地点可能重叠</li>
</ul>
<p><strong>为什么会发生抖动？</strong></p>
<ul>
<li>本地大小&gt;总内存大小<br>激活页面&gt;分配的框架</li>
</ul>
<h3 id="9-6-2工作集模型"><a href="#9-6-2工作集模型" class="headerlink" title="9.6.2工作集模型"></a>9.6.2工作集模型</h3><ul>
<li><strong>工作集模型是基于局部性假设的</strong></li>
<li><strong>采用参数</strong><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122145251540.png" alt="image-20201122145251540"><strong>定义工作集窗口（一下简称delta）</strong></li>
<li><strong>它的思想是检查最近delta个页面引用</strong></li>
<li><strong>这最近delta个页面引用的页面集合称为工作集</strong></li>
<li><strong>如果一个页面处于活动使用状态，那么它处在工作集中</strong></li>
<li><strong>如果它不再使用，那么它在最后一次引用的delta时间单位后，会从工作集中删除。</strong></li>
<li><strong>因此，工作集是程序局部的近似</strong></li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122145733309.png" alt="image-20201122145733309"></p>
<ul>
<li><p>工作集精度：<br>WSSi（Process Pi的工作集）= 最近delta中引用的总页数（随时间变化）<br>   随时间变化，取决于delta的选择</p>
<ul>
<li>如果delta太小 ⇒ 不能包含整个局部</li>
<li>如果delta太大 ⇒ 可能包含多个局部</li>
<li>如果delta = ∞ ⇒ 将涵盖整个程序</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122150151647.png" alt="image-20201122150151647"></p>
</li>
</ul>
<p><strong>选中了delta后，工作集模型的使用就很简单——操作系统监视每个进程的工作集，并为它分配大于其工作集的帧数。如果还有足够的额外帧，那么可启动另一进程。如果工作集大小的总和增加以至于超过可用帧的总数，则操作系统会选择一个进程来挂起，该进程的页面被写出（交换），并且其帧可以分配给其他进程。挂起的进程以后可以重启。</strong></p>
<p><strong>这种工作集策略可以防止抖动，同时保持尽可能高的多道程度，因此它优化了CPU利用率。工作集的困难是跟踪工作集</strong></p>
<p><strong>跟踪工作集</strong></p>
<ul>
<li>近似与：固定间隔计时器+引用位</li>
<li>示例：delta = 10,000<br>   每5000个时间单位后导致计时器中断<br>   每页保留两个内存位<br>   每当计时器中断时，将所有参考位的值复制并设置为0<br>   如果存储器中的一位= 1⇒工作集中的页面</li>
<li>为什么这不完全正确？<br>   在！！ 但是在哪里？<br>改善：<br>*<em>通过增加历史位的数量和中断的频率可以降低这一不不确定性，但是成本更高。**</em>10位，每1000个时间单位中断一次*</li>
</ul>
<h3 id="9-6-3缺页错误频率"><a href="#9-6-3缺页错误频率" class="headerlink" title="9.6.3缺页错误频率"></a>9.6.3缺页错误频率</h3><p>帮助控制抖动</p>
<ul>
<li>抖动具有较高的页面错误率。</li>
<li>建立“可接受的”页面错误率<ul>
<li>如果实际错误率太低，可以从进程中删除一帧</li>
<li>如果实际错误率太高，可以给进程增加一帧</li>
</ul>
</li>
</ul>
<h2 id="9-8分配内核内存"><a href="#9-8分配内核内存" class="headerlink" title="9.8分配内核内存"></a>9.8分配内核内存</h2><p><strong>内核内存</strong><br><strong>与用户内存不同</strong></p>
<ul>
<li><p>进程的逻辑（虚拟）地址空间  VS  内核地址空间</p>
<ul>
<li><p>不同的特权</p>
</li>
<li><p>是否允许页面错误？</p>
</li>
</ul>
</li>
<li><p>通常是从空闲内存池中分配</p>
<ul>
<li>内核请求存储大小不同的数据结构</li>
<li>一些内核内存可能需要物理上驻留的内存连续页面</li>
</ul>
</li>
</ul>
<h3 id="9-8-1伙伴系统"><a href="#9-8-1伙伴系统" class="headerlink" title="9.8.1伙伴系统"></a>9.8.1伙伴系统</h3><ul>
<li>从固定大小的段（由物理上连续的页面组成）分配内存</li>
<li>使用2的幂分配器分配的内存<br>以2的幂为单位满足要求<br>请求四舍五入到下一个最高幂2<br>当需要的分配量小于当前大小时，当前块被分成两个下一个较低次幂2的伙伴，直到可用的大小合适的块</li>
</ul>
<h3 id="9-8-2slab分配器"><a href="#9-8-2slab分配器" class="headerlink" title="9.8.2slab分配器"></a>9.8.2slab分配器</h3><p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122151605316.png" alt="image-20201122151605316"></p>
<ul>
<li>平板是一个或多个物理上连续的页面<br>缓存由一个或多个平板组成<br>每个唯一内核数据结构的单个缓存<br>每个缓存都填充有对象—数据结构的实例<br>创建缓存后，将其填充为标记为空闲的对象<br>存储结构时，将对象标记为已使用<br>如果slab充满了使用过的对象，则从空板<br>如果没有空板，则分配新板</li>
<li>好处：没有碎片，快速的存储请求满足</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="prev" title="内存管理">
                  <i class="fa fa-chevron-left"></i> 内存管理
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eric-scarlet</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>















  








  

  

</body>
</html>
