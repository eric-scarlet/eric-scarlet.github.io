<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>第7章 下推自动机</title>
    <url>/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="第7章-下推自动机"><a href="#第7章-下推自动机" class="headerlink" title="第7章 下推自动机"></a>第7章 下推自动机</h1><h2 id="7-1基本定义"><a href="#7-1基本定义" class="headerlink" title="7.1基本定义"></a>7.1基本定义</h2><a id="more"></a>

<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202161631417.png" alt="image-20201202161631417"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202161652453.png" alt="image-20201202161652453"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202161708223.png" alt="image-20201202161708223"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202161738854.png" alt="image-20201202161738854"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202161756426.png" alt="image-20201202161756426"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202161814136.png" alt="image-20201202161814136"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202161849018.png" alt="image-20201202161849018"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202161907688.png" alt="image-20201202161907688"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202161926441.png" alt="image-20201202161926441"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162014450.png" alt="image-20201202162014450"></p>
<p><strong>重要：</strong></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162055173.png" alt="image-20201202162055173"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162115320.png" alt="image-20201202162115320"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162129306.png" alt="image-20201202162129306"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162141367.png" alt="image-20201202162141367"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162236335.png" alt="image-20201202162236335"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162248183.png" alt="image-20201202162248183"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162257517.png" alt="image-20201202162257517"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162306702.png" alt="image-20201202162306702"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162321576.png" alt="image-20201202162321576"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162354522.png" alt="image-20201202162354522"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162414566.png" alt="image-20201202162414566"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162426347.png" alt="image-20201202162426347"></p>
<p><img src="/2020/12/02/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/image-20201202162443784.png" alt="image-20201202162443784"></p>
]]></content>
      <categories>
        <category>形式语言与自动机理论</category>
      </categories>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="第十章-文件系统"><a href="#第十章-文件系统" class="headerlink" title="第十章 文件系统"></a>第十章 文件系统</h1><h2 id="10-1文件概念"><a href="#10-1文件概念" class="headerlink" title="10.1文件概念"></a>10.1文件概念</h2><h3 id="10-1-1文件属性"><a href="#10-1-1文件属性" class="headerlink" title="10.1.1文件属性"></a>10.1.1文件属性</h3><p><strong>文件的属性因操作系统而异，但通常包括：</strong></p>
<ul>
<li>名称：符号文件名是以人类可读形式来保存的唯一信息。</li>
<li>标识符：这种唯一标记（通常为数字）标识文件系统的文件；它是文件的非人类可读的名称。</li>
<li>类型：支持不同类型文件的系统需要这种信息。</li>
<li>位置：该信息为指向设备与设备上文件位置的指针。</li>
<li>尺寸：该属性包括文件的当前大小（以字节、字或块为单位 ）以及可能允许的最大尺寸。</li>
<li>保护：访问控制信息确定谁能进行读取、写入、执行等。</li>
<li>时间、日期和用户标识：文件创建、最后修改和最后使用的相关信息可以保存、这些数据用于保护、安全和使用监控。</li>
</ul>
<p><strong>所有文件的信息保存在目录结构中，该目录结构也保存在外存上。</strong><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201130083735047.png" alt="image-20201130083735047"></p>
<p><strong>通常，目录条目由文件的名称及其唯一标识符组成。根据标识符可定位其他文件属性。</strong></p>
<h3 id="10-1-2文件操作"><a href="#10-1-2文件操作" class="headerlink" title="10.1.2文件操作"></a>10.1.2文件操作</h3><p><strong>文件是一种抽象的数据类型。 操作系统提供了6个基本的系统调用：</strong></p>
<ul>
<li><p>创建：分配空间+创建目录条目</p>
</li>
<li><p>写：写指针</p>
</li>
<li><p>读取：读取指针</p>
</li>
<li><p>重新定位文件：也称为查找</p>
</li>
<li><p>删除：释放空间+擦除目录项</p>
</li>
<li><p>截断：文件len = 0; 释放空间； 所有其他属性保持不变</p>
</li>
<li><p>其他：<br>对于文件：追加，重命名<br>对于文件属性：chown，chmod<br>对于目录和目录条目：<br>打开（Fi）-在磁盘上的目录结构中搜索条目Fi，<br>并将条目内容移至内存<br>关闭（Fi）-将内存中条目Fi的内容移动到磁盘上的目录结构</p>
</li>
</ul>
<h4 id="打开文件和打开文件表"><a href="#打开文件和打开文件表" class="headerlink" title="打开文件和打开文件表"></a>打开文件和打开文件表</h4><p>打开文件表，OFT：包含所有打开文件的信息的小表<br>多个进程可能会同时打开同一文件<br>⇒2级：每个进程表和一个系统范围表，具有与进程无关的信息</p>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204095435008.png" alt="image-20201204095435008"></p>
<p>每次打开文件都有如下关联信息：</p>
<ul>
<li>文件指针：指向上次读/写位置的指针，与进程有关</li>
<li>文件打开计数：跟踪打开和关闭的次数–允许在最后一个进程关闭它时从打开文件表中删除该条目</li>
<li>文件的磁盘位置：在磁盘上找到文件所需的信息，始终保存在内存中</li>
<li>访问权限：每个进程的访问方式信息</li>
</ul>
<h4 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h4><p><strong>有的操作系统提供功能，用于锁定打开的文件（或文件的部分）</strong><br><strong>文件锁允许一个进程锁定文件并阻止其他进程访问该文件</strong><br>功能类似于读者-写者锁<br>共享锁（共享锁）类似于读者锁-多个进程可以同时获取<br>独占锁（专用锁）类似于写者锁<br>依赖于操作系统或文件系统</p>
<h4 id="强制或建议文件锁定机制"><a href="#强制或建议文件锁定机制" class="headerlink" title="强制或建议文件锁定机制"></a>强制或建议文件锁定机制</h4><p>1.强制：例如Windows操作系统</p>
<ul>
<li><strong>一旦进程获取独占锁，操作系统就阻止任何其他进程访问锁定的文件</strong></li>
<li><strong>操作系统确保锁定完整性</strong></li>
</ul>
<p>2.建议：例如UNIX</p>
<ul>
<li>进程可以找到锁的状态并决定要做什么</li>
<li><strong>软件开发人员应确保适当地获取和释放锁</strong></li>
</ul>
<h3 id="10-1-3文件类型"><a href="#10-1-3文件类型" class="headerlink" title="10.1.3文件类型"></a>10.1.3文件类型</h3><p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204100904325.png" alt="image-20201204100904325"></p>
<h3 id="10-1-4文件结构"><a href="#10-1-4文件结构" class="headerlink" title="10.1.4文件结构"></a>10.1.4文件结构</h3><p><strong>文件类型也可用于指示文件的内部结构</strong></p>
<h4 id="文件结构（逻辑上）"><a href="#文件结构（逻辑上）" class="headerlink" title="文件结构（逻辑上）"></a><strong>文件结构（逻辑上）</strong></h4><ul>
<li><p>字，字节的无序</p>
</li>
<li><p>简单的记录结构</p>
<ul>
<li>线数</li>
<li>固定长度</li>
<li>可变长度</li>
</ul>
</li>
<li><p>复杂结构</p>
<ul>
<li>格式化文件</li>
<li>可重载文件</li>
</ul>
</li>
<li><p>通过插入适当的控制字符，可以用第一种方法模拟最后两个</p>
</li>
</ul>
<h4 id="系统支持的文件结构"><a href="#系统支持的文件结构" class="headerlink" title="系统支持的文件结构"></a><strong>系统支持的文件结构</strong></h4><ul>
<li>大多数现代OS直接支持最少数量的文件结构<ul>
<li>示例：UNIX将每个文件视为8位字节的序列</li>
</ul>
</li>
<li>好处<ul>
<li>应用程序具有更大的灵活性</li>
<li>简化操作系统</li>
</ul>
</li>
</ul>
<h3 id="10-1-5内部文件结构"><a href="#10-1-5内部文件结构" class="headerlink" title="10.1.5内部文件结构"></a>10.1.5内部文件结构</h3><ul>
<li>如何在文件中找到偏移量？<ul>
<li>逻辑文件（记录）（长度不同）<br>→物理块（固定大小）</li>
</ul>
</li>
<li>解决方案：打包-将许多逻辑记录打包到物理块中。<ul>
<li>打包和解包：在逻辑记录和物理块之间转换</li>
<li>内部碎片会产生</li>
</ul>
</li>
</ul>
<h2 id="10-2访问方法"><a href="#10-2访问方法" class="headerlink" title="10.2访问方法"></a>10.2访问方法</h2><p>文件存储信息。 使用时，必须访问此信息并将其读入计算机内存<br>从用户的逻辑角度来看，可以通过几种方式访问文件中的信息</p>
<h3 id="10-2-1顺序访问"><a href="#10-2-1顺序访问" class="headerlink" title="10.2.1顺序访问"></a>10.2.1顺序访问</h3><p><strong>顺序访问方式</strong>：最简单的访问方法。 文件中的信息按顺序处理，一个记录一个接一个。</p>
<ul>
<li>这是最常见的访问模式<br>例如：编辑器，编译器</li>
<li>文件的磁带模型</li>
</ul>
<p><strong>文件操作及其对文件指针的影响</strong></p>
<ul>
<li>读/写下一个</li>
<li>重启</li>
<li>后退/前进 n</li>
</ul>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204101921035.png" alt="image-20201204101921035"></p>
<h3 id="10-2-2直接访问"><a href="#10-2-2直接访问" class="headerlink" title="10.2.2直接访问"></a>10.2.2直接访问</h3><p><strong>这里，文件由固定长度的逻辑记录组成，以允许程序按任意顺序进行快速读取和写入记录。直接访问方法基于文件的磁盘模型，因为磁盘允许对任何文件块的随机访问。对于直接访问，文件可以作为块或记录的编号序列。对于直接访问文件的读取或写入的顺序没有限制</strong></p>
<p><strong>直接访问方式</strong>：文件中的信息没有特别的顺序处理。</p>
<ul>
<li>文件由固定长度的逻辑记录的编号序列组成<ul>
<li>文件的磁盘模型，允许随机访问，立即访问</li>
<li>例如：数据库或航空公司预订系统</li>
</ul>
</li>
<li>通过提供相对记录号可以快速移动到任何记录位置<ul>
<li>读n和写n<br>文件指针 =  L * n，0≤n≤N，其中N是最后一个记录号，L是每个记录的固定长度。</li>
<li>=位置n和下一个读/写</li>
</ul>
</li>
</ul>
<p><strong>直接访问文件的顺序访问模拟：</strong></p>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204102908265.png" alt="image-20201204102908265"></p>
<h3 id="10-2-3其他访问方法（索引访问方式）"><a href="#10-2-3其他访问方法（索引访问方式）" class="headerlink" title="10.2.3其他访问方法（索引访问方式）"></a>10.2.3其他访问方法（索引访问方式）</h3><ul>
<li><p><strong>为了缩短搜索时间并减少I / O</strong></p>
</li>
<li><p>为该文件创建一个索引文件，其中包含指向各种记录的指针</p>
</li>
<li><p>首先搜索索引文件，然后使用指针直接访问该文件并找到所需的记录</p>
</li>
<li><p>对于大文件，索引文件本身可能会变得太大而无法保存在内存中⇒多级索引表</p>
</li>
</ul>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204103150754.png" alt="image-20201204103150754"></p>
<h2 id="10-3目录与磁盘结构"><a href="#10-3目录与磁盘结构" class="headerlink" title="10.3目录与磁盘结构"></a>10.3目录与磁盘结构</h2><p><strong>分区（迷你磁盘，卷）</strong></p>
<ul>
<li>一个磁盘</li>
<li>磁盘的一部分：在一个磁盘上提供单独的逻辑空间</li>
<li>N个磁盘：将多个磁盘分组为一个逻辑空间</li>
</ul>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204103736677.png" alt="image-20201204103736677"></p>
<p><strong>分区 = 文件 + 目录</strong></p>
<ul>
<li>目录：保存该分区中所有文件的文件信息（名称，位置，大小，类型…）</li>
</ul>
<h3 id="10-3-1存储结构"><a href="#10-3-1存储结构" class="headerlink" title="10.3.1存储结构"></a>10.3.1存储结构</h3><p>正如刚才所述.jpg</p>
<p>专用文件系统</p>
<ul>
<li>临时文件系统</li>
<li>“虚拟”文件系统</li>
<li>维护合同信息的虚拟文件系统</li>
<li>环回文件系统</li>
<li>虚拟文件系统</li>
<li>通用文件系统</li>
</ul>
<h3 id="10-3-2目录概述"><a href="#10-3-2目录概述" class="headerlink" title="10.3.2目录概述"></a>10.3.2目录概述</h3><p><strong>目录：包含有关所有文件信息的节点的集合。</strong></p>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204104415132.png" alt="image-20201204104415132"></p>
<p><strong>目录 + 文件：全部驻留在磁盘上</strong><br><strong>这两个结构的备份保存在磁带上</strong></p>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204104452788.png" alt="image-20201204104452788"></p>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204104517963.png" alt="image-20201204104517963"></p>
<p><strong>组织目录（逻辑上）以获取</strong></p>
<ul>
<li>效率——快速查找文件</li>
<li>命名——方便用户<ul>
<li>两个用户可以为不同的文件使用相同的名称</li>
<li>同一文件可以具有多个不同的名称</li>
</ul>
</li>
<li>分组——人们的惯例<ul>
<li>按属性对文件进行逻辑分组（例如，所有Java程序，所有游戏等）</li>
</ul>
</li>
</ul>
<h3 id="10-3-3单级目录"><a href="#10-3-3单级目录" class="headerlink" title="10.3.3单级目录"></a>10.3.3单级目录</h3><p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204104857734.png" alt="image-20201204104857734"></p>
<ul>
<li>所有用户的一个目录</li>
<li>易于支持和理解。</li>
<li>但是，如果有大量文件和/或用户……<ul>
<li>极低的搜索速度，O（N）</li>
<li>命名问题<ul>
<li>命名空间小和名称冲突</li>
<li>MS-DOS：11个字节的文件名</li>
<li>UNIX：256个字节</li>
</ul>
</li>
<li>保护VS共享</li>
<li>分组问题</li>
</ul>
</li>
</ul>
<h3 id="10-3-4两级目录"><a href="#10-3-4两级目录" class="headerlink" title="10.3.4两级目录"></a>10.3.4两级目录</h3><p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204105848435.png" alt="image-20201204105848435"></p>
<ul>
<li><p>对于两级目录结构，每个用户都有自己的用户文件目录</p>
</li>
<li><p>用户文件目录：UFD</p>
<ul>
<li>每个条目都拥有用户文件的信息</li>
</ul>
</li>
<li><p>主文件目录：MFD</p>
<ul>
<li>每个条目包含：（1）用户名，（2）指向其UFD的指针</li>
</ul>
</li>
<li><p>可以为不同的用户使用相同的文件名</p>
</li>
<li><p>高效搜索</p>
</li>
<li><p>没有分组能力</p>
</li>
<li><p>易于管理</p>
<ul>
<li>添加/删除用户</li>
</ul>
</li>
<li><p>安全VS。 分享中</p>
<ul>
<li>MFD，系统管理员</li>
<li>UFD，与其他用户隔离</li>
<li>目录树和路径名</li>
<li>如何分享？ 例如。 系统范围的文件（数据，程序等）<ul>
<li>为每个用户复制</li>
<li>搜索路径：一个特殊的用户目录定义成包含系统文件，每当需要加载给定名称的文件时，操作系统首先搜索本地UFD，如果找到则使用，如果没找到，系统就自动搜索包含系统文件的特殊用户目录。用于搜索给定名称的文件所用的目录序列称为<strong>搜索路径</strong>。</li>
<li>对于给定的命令名称，搜索路径可以扩展到包含需要搜索的无限的目录列表。这种方法是UNIX和Windows最为常用的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-3-5树形目录"><a href="#10-3-5树形目录" class="headerlink" title="10.3.5树形目录"></a>10.3.5树形目录</h3><p><strong>根目录+目录+子目录</strong></p>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204110135045.png" alt="image-20201204110135045"></p>
<p><strong>常规文件 VS. 子目录</strong><br>将子目录视为另一个文件<br>使用目录条目中的特殊位来区分文件（0）和子目录（1）</p>
<p><strong>当前目录（工作/搜索目录）</strong><br>在当前目录中创建一个新文件。<br>初始当前目录</p>
<p><strong>绝对与相对路径名</strong><br>如果当前目录是root / spell / mail，则相对路径名prt / first<br>prt / first与绝对路径名root / spell / mail / prt / first所指的文件相同</p>
<p><strong>操作</strong></p>
<ul>
<li>更改当前目录：cd / spell / mail / prog</li>
<li>删除文件：rm &lt;文件名&gt;</li>
<li>列出目录：ls</li>
<li>创建一个新目录：mkdir <dir-name><ul>
<li>示例：如果在当前目录/ mail中</li>
</ul>
</dir-name></li>
<li>删除目录<ul>
<li>MS-DOS（仅空目录）VS。 UNIX（可选）</li>
</ul>
</li>
</ul>
<p><strong>高效搜索</strong><br><strong>分组能力</strong><br><strong>树形结构</strong><br><strong>禁止（阻止）共享文件和目录。</strong></p>
<h3 id="10-3-6无环图目录"><a href="#10-3-6无环图目录" class="headerlink" title="10.3.6无环图目录"></a>10.3.6无环图目录</h3><p>具有共享子目录和文件，没有环<br>同一文件或目录可能位于两个不同的目录中，具有两个不同的名称（别名）</p>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204110705454.png" alt="image-20201204110705454"></p>
<p><strong>执行：</strong></p>
<ul>
<li>符号链接（符号链接）<ul>
<li>特殊的新目录条目（链接）</li>
<li>该文件的内容是真实文件/目录的路径名</li>
</ul>
</li>
<li>复制目录条目<ul>
<li>难以保持一致性</li>
</ul>
</li>
</ul>
<p><strong>遍历问题</strong><br>名称不同，实际只有一个文件<br>遍历不止一次</p>
<p><strong>删除问题</strong><br>如果直接删除列表⇒悬空指针<br>或保留文件，直到删除对该文件的所有引用<br>解决方案：<br>-文件参考清单<br>-参考计数：UNIX中的硬链接（hard link）<br>如何确保没有周期？</p>
<h3 id="10-3-7通用图目录"><a href="#10-3-7通用图目录" class="headerlink" title="10.3.7通用图目录"></a>10.3.7通用图目录</h3><p>允许环存在于目录中</p>
<p><img src="/2020/11/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20201204110938967.png" alt="image-20201204110938967"></p>
<p><strong>遍历问题和删除问题仍然存在，甚至更加复杂</strong></p>
<ul>
<li>无限循环<ul>
<li>限制搜索时目录的访问号</li>
</ul>
</li>
<li>垃圾和垃圾收集</li>
</ul>
<p><strong>我们如何保证没有周期？</strong></p>
<ul>
<li>只允许链接到文件而不是子目录</li>
<li>每次添加新链接时，请使用周期检测算法确定是否正常</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第八讲 查找</title>
    <url>/2020/12/03/%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><!-- more --->

<p><strong>以iPad上笔记为基础</strong></p>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203132413910.png" alt="image-20201203132413910"></p>
<p><strong>顺序查找查找过程：从表中最后一个记录开始逐个进行记录的关键字和给定值的比较。</strong></p>
<p><strong>平均查找长度：</strong><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203132839519.png" alt="image-20201203132839519"></p>
<p><strong>其中Pi是第i个记录的搜索概率（频率）；</strong><br><strong>Ci是搜索键比较时的计数。</strong></p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203132644323.png" alt="image-20201203132644323"></p>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p><strong>初始化：设置low= 0，high=列表长度。</strong><br><strong>重复以下步骤：</strong><br><strong>如果low&gt;high，则返回–1表示未找到项目。</strong><br><strong>mid = 中间元素在子列表中的位置。</strong><br><strong>如果K &lt; ST [mid] .key，则high = mid - 1 //搜索列表的左半部分**<br>**否则，如果K &gt; ST [mid] .key，则low = mid + 1 //搜索列表的右半部分</strong><br><strong>否则返回mid作为目标位置 //搜索成功</strong></p>
<p>折半查找判定树：</p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203133253025.png" alt="image-20201203133253025"></p>
<p>由算法在特定搜索中完成的比较次数是从树的顶部向下到相应路径的遍历内部节点的次数。</p>
<p>折半查找平均查找长度：</p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203133403889.png" alt="image-20201203133403889"></p>
<p><strong>但是如果是题目给定的有限数量的查找请不要用这个公式而是直接手算。</strong></p>
<h3 id="索引查找"><a href="#索引查找" class="headerlink" title="索引查找"></a>索引查找</h3><p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203130538987.png" alt="image-20201203130538987"></p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203130651807.png" alt="image-20201203130651807"></p>
<p><strong>搜索比较：</strong></p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203133518234.png" alt="image-20201203133518234"></p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>二叉排序树或者是一棵空树；或者是具有下列性质的二叉树：</p>
<p>1.若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。</p>
<p>2.若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。</p>
<p>3.它的左，右子树也分别为二叉排序树。</p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203134423418.png" alt="image-20201203134423418"></p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203134542809.png" alt="image-20201203134542809"></p>
<p>3种删除可能：</p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203134605466.png" alt="image-20201203134605466"></p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203134703433.png" alt="image-20201203134703433"></p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203134718642.png" alt="image-20201203134718642"></p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203134732400.png" alt="image-20201203134732400"></p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203134749350.png" alt="image-20201203134749350"></p>
<p><img src="/2020/12/03/%E6%9F%A5%E6%89%BE/image-20201203134802159.png" alt="image-20201203134802159"></p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h3><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><h3 id="冲突解决方案"><a href="#冲突解决方案" class="headerlink" title="冲突解决方案"></a>冲突解决方案</h3><h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h4><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><h3 id="哈希表的分析"><a href="#哈希表的分析" class="headerlink" title="哈希表的分析"></a>哈希表的分析</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="第八章-内存管理"><a href="#第八章-内存管理" class="headerlink" title="第八章 内存管理"></a>第八章 内存管理</h1><h2 id="8-1背景"><a href="#8-1背景" class="headerlink" title="8.1背景"></a>8.1背景</h2><h3 id="8-1-1基本硬件"><a href="#8-1-1基本硬件" class="headerlink" title="8.1.1基本硬件"></a>8.1.1基本硬件</h3><a id="more"></a>

<ul>
<li><p>高速缓存</p>
<p>将信息复制到更快的存储系统<br>访问时，请首先检查缓存，<br>如果在：直接使用<br>不在：从上层存储系统获取，并将副本保留在缓存中<br>使用缓存<br>寄存器为主存储器提供高速缓存<br>指令缓存和数据缓存<br>主内存可以视为辅助存储的快速缓存</p>
<p>必须将程序（从磁盘）带入内存并放置在进程中才能运行<br>主存储器和寄存器仅是存储CPU可以直接访问<br>一个CPU时钟（或更少）中的Registeraccess<br>主内存可能需要很多周期（几个CPU时钟）<br>缓存在主内存和CPU寄存器之间进行<br>内存的保护需要保证正确的操作</p>
</li>
<li><p>内存保护<br>基地址寄存器和界限地址寄存器定义了逻辑地址空间</p>
<ul>
<li>基地址寄存器＋界限地址寄存器</li>
<li>外部存储器受到保护</li>
<li>操作系统可以不受限制地访问显示器和用户的内存</li>
<li>只有操作系统可以通过特殊的特权指令，才能加载基地址寄存器和界限地址寄存器。</li>
</ul>
</li>
</ul>
<h3 id="8-1-2地址绑定"><a href="#8-1-2地址绑定" class="headerlink" title="8.1.2地址绑定"></a>8.1.2地址绑定</h3><ul>
<li><p>将指令和数据绑定到内存</p>
</li>
<li><p>符号地址到可重定位地址</p>
</li>
<li><p>可重定位地址到绝对地址</p>
</li>
<li><p>指令和数据到内存地址的地址绑定可以分为三个不同的阶段</p>
</li>
<li><p>通常，指令和数据绑定到存储器地址可在沿途的任何一步进行：</p>
</li>
<li><p>编译时：若编译时就已经知道程序的驻留地址，就可以生成绝对代码</p>
</li>
<li><p>如果内存位置被称为先验，则可以生成绝对代码（absolute code）；<br>如果起始位置更改，则必须重新编译代码；<br>示例：MS-DOS .COM格式程序</p>
</li>
<li><p>加载时：（可重定位代码）<br>如果在编译时不知道内存位置，则必须生成可重定位代码（可重定位代码）</p>
</li>
<li><p>执行时：</p>
<p>若进程可以在执行时从一个内存段转移到另一个内存段，那么绑定应当延迟到执行时才进行，采用这种方案需要特定硬件，大多数通用计算机操作系统采用该方法。</p>
</li>
<li><p>用户程序的多步骤处理：</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201112202116682.png" alt="image-20201112202116682"></p>
<h3 id="8-1-3逻辑地址空间与物理地址空间"><a href="#8-1-3逻辑地址空间与物理地址空间" class="headerlink" title="8.1.3逻辑地址空间与物理地址空间"></a>8.1.3逻辑地址空间与物理地址空间</h3><ul>
<li><p>CPU生成的地址通常称为逻辑地址，而内存单元看到的地址（即加载到内存地址寄存器的地址）通常称为物理地址。</p>
</li>
<li><p>编译时和加载时的地址绑定方法生成相同的逻辑地址和物理地址。但是执行时的地址绑定方案生成不同的逻辑地址和物理地址，在该情况下通常称逻辑地址为虚拟地址。由程序生成的所有逻辑地址的集合称为逻辑地址空间，这些逻辑地址对应的所有物理地址的集合称为物理地址空间。</p>
</li>
<li><p>内存管理单元（MMU）<br>将虚拟地址映射到物理地址的硬件设备<br>在MMU方案中，重定位寄存器中的值被添加到用户进程当时生成的每个地址中，然后将其发送到内存中。<br>用户程序处理逻辑地址； 它从来没有看到真正的物理地址。</p>
</li>
<li><p>使用重定位寄存器的动态重定位：</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201112202128762.png" alt="image-20201112202128762"></p>
<h3 id="8-1-4动态加载"><a href="#8-1-4动态加载" class="headerlink" title="8.1.4动态加载"></a>8.1.4动态加载</h3><p>加载的三种方式：</p>
<ul>
<li>绝对加载方式</li>
<li>可重定位装入方式</li>
<li>动态运行时装入方式</li>
</ul>
<p>绝对加载方式</p>
<p>编译：</p>
<ul>
<li>具有绝对地址的绝对代码<br>正在加载：</li>
<li>必须加载到指定地址</li>
<li>加载地址=绝对地址</li>
<li>执行：</li>
<li>逻辑地址=绝对地址</li>
<li>适用于简单的批处理系统（单道系统）</li>
</ul>
<p>可重定位装入方式</p>
<ul>
<li>通常，在编译时无法知道加载地址，而只能在加载时确定。<br>编译：</li>
<li>code带有相对地址的可重定位代码</li>
<li>正在加载：</li>
<li>执行：根据加载地址，将文件中的相对地址修改为内存中的绝对地址</li>
<li>这称为重定位（relocation）</li>
<li>静态静态重定位：</li>
<li>地址绑定在加载时完成一次，然后将不会更改</li>
<li>逻辑地址=绝对地址</li>
<li>适用于多道系统</li>
</ul>
<p>动态运行时装入方式</p>
<ul>
<li><p>基于参照性原则</p>
</li>
<li><p>将主程序加载到内存中并执行</p>
</li>
<li><p>例程不被加载，直到被调用</p>
</li>
<li><p>执行时加载：需要可重定位的链接加载器</p>
</li>
<li><p>loading加载前：可重定位代码</p>
</li>
<li><p>通话时而不是：</p>
<p>加载所需的例程，更新程序的地址表</p>
<p>并将控制权传递给新加载的例程</p>
</li>
<li><p>优点：<br>更好的内存空间利用率；<br>未使用的例程永远不会加载。</p>
</li>
<li><p>当需要大量代码来处理异常（例如错误进程）时很有用</p>
</li>
<li><p>不需要操作系统的特殊支持</p>
</li>
<li><p>用户责任是设计他们的程序利用这种方法的优点</p>
</li>
<li><p>操作系统可以通过实现动态加载的程序库来帮助程序员</p>
</li>
</ul>
<h3 id="8-1-5动态联建与共享库"><a href="#8-1-5动态联建与共享库" class="headerlink" title="8.1.5动态联建与共享库"></a>8.1.5动态联建与共享库</h3><p>链接：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201112203018298.png" alt="image-20201112203018298"></p>
<p>根据链接的时间可以分为：</p>
<ul>
<li>静态链接方式</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ul>
<p>静态链接方式</p>
<ul>
<li>加载之前，所有对象模块和所需的库都链接到一个可加载的二进制程序映像中。<br>在对象模块和（静态）库中：相对地址<br>存在外部呼叫或对外部符号的引用</li>
<li>（函数或变量）：<br>对象模块←→对象模块； 对象模块→库</li>
<li>连结时<br>相对地址被修改：<br>多个相对地址空间→一个相对地址空间<br>外部调用和引用是定界的</li>
<li>这种功能通常用于系统库，如语言的子程序库。没有这种功能，系统内所有的程序都需要一份语言库的副本，这种要求浪费了磁盘空间和内存空间。</li>
<li>坏处：<br>系统上的每个程序都必须包含必需的副本<br>库（或至少必需的例程）<br>例如语言库</li>
</ul>
<p>装入时动态链接</p>
<ul>
<li><p>加载时链接：</p>
</li>
<li><p>外部调用和引用是定界的<br>根据外部调用和引用，加载<br>程序找到所需的对象模块和库，并<br>将它们加载到内存中</p>
</li>
<li><p>相对地址被修改：<br>多个相对地址空间→一个相对地址空间</p>
</li>
<li><p>优点：<br>易于修改和更新对象模块和库<br>轻松共享对象模块和库</p>
</li>
</ul>
<p>运行时动态链接</p>
<ul>
<li>每次执行时，一个程序可能不同<ul>
<li>链接推迟到执行时间</li>
</ul>
</li>
<li>链接时：<ul>
<li>每个库例程的映像中都包含一个stubis<br>参考资料</li>
<li>stubis是一小段代码，用于查找<br>适当的内存驻留库例程</li>
</ul>
</li>
<li>执行期间：<ul>
<li>存根将其自身替换为例程的地址，并且<br>执行例程</li>
<li>操作系统需要检查例程是否在进程的内存地址中<br>动态链接对于库-共享库特别有用<br>优点：加载时间短，存储空间少</li>
</ul>
</li>
</ul>
<h2 id="8-2交换"><a href="#8-2交换" class="headerlink" title="8.2交换"></a>8.2交换</h2><ul>
<li>进程必须在内存中以便执行。不过，内存可以暂时从<strong>内存</strong>交换到<strong>备份存储</strong>，当再次执行时再调回到内存中。交换有可能让所有进程的总的物理地址空间超过真实系统的物理地址空间，从而增加了系统的<strong>多道程序程度</strong>。</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201112230619494.png" alt="image-20201112230619494"></p>
<h3 id="8-2-1标准交换"><a href="#8-2-1标准交换" class="headerlink" title="8.2.1标准交换"></a>8.2.1标准交换</h3><ul>
<li><p>交换要求：<br>对换空间<br> 换出（或滚出）<br> 换入（或滚入）</p>
</li>
<li><p>备份存储：足够大的快速磁盘，可以容纳所有用户的所有内存映像副本； 必须提供对这些内存映像的直接访问</p>
<ul>
<li><p>为了加快速度，请考虑连续分配，并忽略碎片问题</p>
</li>
<li><p>需要提供数据结构来管理空闲磁盘块</p>
<ul>
<li>类似于动态分区分配</li>
</ul>
</li>
</ul>
</li>
<li><p>进程换出</p>
<ul>
<li>步骤1：选择要换出的流程</li>
<li>RR调度：<br>时间片到期时换出<br>基于优先级的调度：推出，推出<br>较低优先级的进程被换出，因此可以加载和执行较高优先级的进程。</li>
<li>步骤2：换出<br>确定要换出的内容<br>（1）不可共享的代码段和数据段<br>（2）可共享的代码和数据段：counter（计数器）<br>  在后备存储上分配空间，换出并修改相关数据结构</li>
</ul>
</li>
<li><p>进程换入</p>
<ul>
<li><p>步骤1：选择要交换的进程</p>
<p>具有静态就绪状态（静止就绪状态）的进程+其他<br>原则<br>-就绪队列：后备存储或存储中的所有就绪进程<br>记忆</p>
</li>
<li><p>步骤2：分配内存空间并交换<br>-如果有可用的内存…<br>-否则，通过换出其他进程来释放内存<br>交换时间的主要部分是传输时间； 总传输时间与所交换的内存量成正比<br>在许多系统（例如UNIX，Linux和Windows）上都可以找到修改后的交换版本</p>
</li>
</ul>
</li>
</ul>
<h2 id="8-3连续内存分配"><a href="#8-3连续内存分配" class="headerlink" title="8.3连续内存分配"></a>8.3连续内存分配</h2><h3 id="8-3-1内存保护"><a href="#8-3-1内存保护" class="headerlink" title="8.3.1内存保护"></a>8.3.1内存保护</h3><h3 id="8-3-2内存分配"><a href="#8-3-2内存分配" class="headerlink" title="8.3.2内存分配"></a>8.3.2内存分配</h3><h4 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h4><ul>
<li>每个进程都包含在内存的单个连续部分中</li>
<li>单编程内存分配（单一连续）</li>
<li>多分区分配<ul>
<li>固定分区</li>
<li>动态分区（动态分区）</li>
</ul>
</li>
</ul>
<h4 id="单一连续内存分配"><a href="#单一连续内存分配" class="headerlink" title="单一连续内存分配"></a>单一连续内存分配</h4><ul>
<li><p>最简单的方法</p>
</li>
<li><p>至多一次一个进程</p>
</li>
<li><p>主内存通常被划分为两部分：</p>
<ul>
<li>常驻OS，通常以中断向量保存在低内存中</li>
<li>然后将用户进程保存在高内存中</li>
</ul>
</li>
<li><p>内存保护策略：</p>
<p>使用MMU（动态映射逻辑地址），例如：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201112235931211.png" alt="image-20201112235931211"></p>
</li>
<li><p>或者不用任何保护</p>
</li>
</ul>
<h4 id="多分区分配"><a href="#多分区分配" class="headerlink" title="多分区分配"></a>多分区分配</h4><p>使多个用户的进程同时驻留在内存中。</p>
<ul>
<li>用户分区分为n个分区</li>
<li>每个分区可能只包含一个进程<br>1）当分区空闲时，选择输入队列中的进程并将其加载到空闲分区中<br>2）进程终止时，该分区可用于另一个进程</li>
<li>多道程序度（multiprogramming）的程度取决于分区数。</li>
</ul>
<h5 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h5><ul>
<li><p>最简单的多分区方法：IBM OS / 360（MFT）<br>-内存分为几个固定大小的分区<br>-分区大小：相等VS不相等<br>-数据结构与分配算法</p>
</li>
<li><p>缺点</p>
<ul>
<li>较差的内存使用</li>
<li>内部碎片</li>
<li>分配的内存可能会比请求的内存稍大</li>
<li>分区内部的内存，但未使用</li>
</ul>
</li>
</ul>
<h5 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h5><ul>
<li><p>洞–可用内存块</p>
</li>
<li><p>首先，所有内存都被认为是一个大洞。</p>
</li>
<li><p>当过程到达时，将搜索足够大的孔。 如果找到，则会根据需要将内存分配给进程，分区的其余内存将保持可用，以满足未来的请求。</p>
</li>
<li><p>各种大小的孔分散在整个内存中。</p>
</li>
<li><p>操作系统维护有关以下信息：</p>
</li>
<li><p>分配的分区</p>
</li>
<li><p>免费隔板（孔）</p>
</li>
<li><p>例：</p>
</li>
<li><p>可用分区表：需要额外的内存来存储表</p>
</li>
<li><p>可用分区列表：可以利用可用分区存储链接和分区信息</p>
</li>
</ul>
<h5 id="动态内存分配问题"><a href="#动态内存分配问题" class="headerlink" title="动态内存分配问题"></a>动态内存分配问题</h5><ul>
<li><p>如何从空孔列表中满足尺寸n的要求</p>
</li>
<li><p>首次适应：分配足够大的第一个孔</p>
</li>
<li><p>循环首次适应：分配足够大的下一个孔</p>
</li>
<li><p>最佳适应：分配足够大的最小孔；必须搜索整个列表，除非按尺寸排序</p>
<p>生产最小的剩余孔</p>
</li>
<li><p>最差适应（Worst-fit）：分配最大的洞； 还必须搜索整个列表</p>
<p>产生最大的剩余孔</p>
<p>在速度和存储利用率方面，最适合和最适合比最不适合</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201113111613796.png" alt="image-20201113111613796"></p>
<h5 id="动态分区方案"><a href="#动态分区方案" class="headerlink" title="动态分区方案"></a>动态分区方案</h5><ul>
<li><p>优点<br>分区的数量，位置和大小随着进程的移入和移出而动态变化。 它非常灵活，避免了由于固定分区中分区大小不正确而导致的内部碎片，并提高了内存利用率。</p>
</li>
<li><p>缺点<br>随着分配的进行，可用分区可能分散在整个内存中。<br>尽管进行了回收，但内存仍在被越来越多的碎片分割，形成了大量的外部碎片</p>
</li>
<li><p>外部碎片（External Fragmentation）<br>存在总内存空间来满足请求，但不是连续的<br>50％规则，给定N个已分配块，另外0.5 N个块</p>
</li>
</ul>
<h3 id="8-3-3碎片"><a href="#8-3-3碎片" class="headerlink" title="8.3.3碎片"></a>8.3.3碎片</h3><ul>
<li><p>通过压缩减少外部碎片</p>
<p>随机整理内存内容以将所有可用内存放在一个大块中</p>
<p>仅当重定位是动态的并且在执行时完成时才可以压缩</p>
</li>
</ul>
<h2 id="8-4分段"><a href="#8-4分段" class="headerlink" title="8.4分段"></a>8.4分段</h2><h3 id="8-4-1基本方法"><a href="#8-4-1基本方法" class="headerlink" title="8.4.1基本方法"></a>8.4.1基本方法</h3><ul>
<li><p>是支持用户查看内存的内存管理方案</p>
</li>
<li><p>程序是段的集合</p>
</li>
<li><p>段是逻辑单元，包含如下的名称和长度：<br>主程序<br>进程？<br>功能<br>方法（函数）<br>物体<br>局部变量<br>全局变量<br>普通块<br>栈<br>符号表<br>数组</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115124640582.png" alt="image-20201115124640582"></p>
<h3 id="8-4-2分段硬件"><a href="#8-4-2分段硬件" class="headerlink" title="8.4.2分段硬件"></a>8.4.2分段硬件</h3><ul>
<li><p>逻辑地址空间<br>   段的集合，每个段&lt;名称； 长度&gt;</p>
</li>
<li><p>-2-D地址空间<br>   逻辑地址由两个元组组成<br>-&lt;segname; 偏移量&gt;或<br>-&lt;segnum; 偏移量&gt;</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115124855336.png" alt="image-20201115124855336"></p>
<ul>
<li><p>逻辑地址由两个元组组成：<br>&lt;段号，偏移量&gt;</p>
</li>
<li><p>段表–将二维逻辑地址映射到一维物理地址；<br>每个表条目都有：</p>
<pre><code>base –包含段驻留在内存中的起始物理地址
限制-指定段的长度</code></pre>
</li>
<li><p>段表基址寄存器（STBR）指向段表在内存中的位置</p>
</li>
<li><p>段表长度寄存器（STLR）指示程序使用的段数；<br>如果s &lt;STLR，则段号为sis</p>
</li>
</ul>
<p><strong>分段结构：</strong></p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115125010185.png" alt="image-20201115125010185"></p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115125029588.png" alt="image-20201115125029588"></p>
<ul>
<li>例子：<br>分段<br>&lt;segment 2，53&gt;→4300 + 53 = 4353<br>&lt;segment 3，852&gt;→3200 + 852 = 4052</li>
</ul>
<h4 id="分页和分段之间的区别"><a href="#分页和分段之间的区别" class="headerlink" title="分页和分段之间的区别"></a>分页和分段之间的区别</h4><ul>
<li>动机和目的<ul>
<li>分页：   分页：面向系统，物理上离散，减少内部和内部碎片，内存实用程序↑<ul>
<li>页面是信息的物理单位   </li>
</ul>
</li>
<li>分段：面向用户，逻辑上离散，满足用户需求<ul>
<li>段是具有相对完整含义的信息的逻辑单元</li>
</ul>
</li>
</ul>
</li>
<li>大小<pre><code>分页：大小是固定的，取决于硬件
细分：大小不固定，取决于程序和</code></pre>
在编译时决定</li>
<li>维度<pre><code>分页：1-D
细分：二维，细分名称（数字）+细分偏移</code></pre>
</li>
</ul>
<h2 id="8-5分页"><a href="#8-5分页" class="headerlink" title="8.5分页"></a>8.5分页</h2><p>分段允许进程的物理地址空间是不连续的。分页是提供这种优势的另一种内存管理方案</p>
<p>进程的LAS可以是不连续的； 只要有可用的物理内存，就为进程分配物理内存</p>
<h3 id="8-5-1基本方法"><a href="#8-5-1基本方法" class="headerlink" title="8.5.1基本方法"></a>8.5.1基本方法</h3><ul>
<li><p>将物理内存分为固定大小的块，称为帧（物理页框）：大小为2的幂，512B-8,192B</p>
</li>
<li><p>页面帧号（物理页框号，PFN）：0,1，…，PFNmax</p>
</li>
<li><p>将逻辑内存划分为相同大小的块，称为页面（逻辑页，页）<br>逻辑页框号，LFN：<br>0,1，…，LFNmax</p>
</li>
<li><p>例如，逻辑地址空间现在完全独立于物理地址空间，因此，一个进程可以有一个64位的逻辑地址空间，而系统的物理内存小于2的64次方字节。</p>
</li>
<li><p><strong>由CPU生成的每个地址分为两部分：页码和页偏移。页码作为页表的索引。页表包含每页所在物理内存的基地址。这个基地址与页偏移的组合就形成了物理内存地址，可发送到物理单元。</strong></p>
</li>
<li><p>需要分页的硬件和软件支持</p>
<ul>
<li>跟踪所有空闲帧</li>
<li>要运行大小为n页的程序，需要找到n个空闲帧并加载程序</li>
<li>设置页表以将每个进程的逻辑地址转换为物理地址</li>
</ul>
</li>
<li><p>内部碎片&lt;页面大小</p>
</li>
</ul>
<h4 id="地址翻译方案"><a href="#地址翻译方案" class="headerlink" title="地址翻译方案"></a>地址翻译方案</h4><ul>
<li><p>CPU生成的地址分为：</p>
</li>
<li><p>页码（p），LFN-包含每个页的基地址的页表索引</p>
</li>
<li><p>页面偏移量（d）–与基地址结合以定义物理地址</p>
</li>
<li><p>如何获得p和d？</p>
</li>
<li><p>页码（p），LFN</p>
</li>
<li><p>页面偏移量（d）</p>
</li>
<li><p>如何获得p和d？</p>
</li>
<li><p>答：一个地址，可以是逻辑地址或物理地址<br>L：页面或页面框架的大小<br>p和d：页码的对应编号和页偏移</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114171330483.png" alt="image-20201114171330483"></p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114171439009.png" alt="image-20201114171439009"></p>
<p>分页硬件：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114171507220.png" alt="image-20201114171507220"></p>
<p>分页例子：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114171522880.png" alt="image-20201114171522880"></p>
<ul>
<li><p>如上图，逻辑的地址的n为2，m为4.采用大小为4字节而物理内存为32字节。</p>
</li>
<li><p>逻辑地址0的页码为0，页偏移为0。根据页表，可以查到页码0对应帧5，因此逻辑地址0映射到物理地址20[= (5 * 4) + 0]。逻辑地址3（页码为0，页偏移为3）映射到物理地址23[= (5 * 4) + 3]。逻辑地址4页码为1，页偏移为0；根据页表，页码为1对应帧6.因此，逻辑地址4映射到物理地址24[= (6 * 4) + 0]。逻辑地址13映射到物理地址9。</p>
</li>
</ul>
<h4 id="自由框架"><a href="#自由框架" class="headerlink" title="自由框架"></a>自由框架</h4><p>由于操作系统正在管理物理内存，因此它必须了解物理内存的分配详细信息</p>
<ul>
<li>分配哪些帧</li>
<li>哪些框架可用</li>
<li>总帧数</li>
<li>框架表：每个物理页面框架一个条目</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114201743107.png" alt="image-20201114201743107"></p>
<h3 id="8-5-2硬件支持"><a href="#8-5-2硬件支持" class="headerlink" title="8.5.2硬件支持"></a>8.5.2硬件支持</h3><ul>
<li>需要特殊的硬件（软件）来实现页表<ul>
<li>基本的分页硬件</li>
<li>带TLB的分页硬件</li>
</ul>
</li>
</ul>
<h4 id="基本的分页硬件"><a href="#基本的分页硬件" class="headerlink" title="基本的分页硬件"></a>基本的分页硬件</h4><ul>
<li><p>页表保存在主存储器中</p>
<ul>
<li><p>页表基址寄存器（PTBR）指向页表</p>
</li>
<li><p>页表长度寄存器（PRLR）指示页表的大小</p>
</li>
</ul>
</li>
<li><p>上下文切换中<br>每个进程都与页表关联。<br>页表也必须切换。</p>
</li>
<li><p>有效内存访问时间（EAT，有效访问时间）<br>-每个数据/指令访问都需要两个内存<br>访问。<br>一个用于页表<br>一种用于数据/指令。</p>
</li>
<li><p>两种内存访问问题的解决方案：<br>一种特殊的快速查找硬件缓存，称为关联存储器或转换后备缓冲器（TLB）</p>
</li>
</ul>
<p>书上：最为简单的一种方法是将页表作为一组专用的寄存器来实现，CPU分派器在加载其他寄存器时也需要加载这些寄存器。加载或修改页表寄存器的指令是特权的，因此只有操作系统可以修改内存映射表。若页表较小（256个条目）那么页表使用寄存器还是令人满意，但是当有100万个条目时，利用快速寄存器就不大可行，因此需要将页表放在内存中并将PTBR指向页表，改变页表只需改变这一个寄存器就可以，大大降低了上下文切换的时间。</p>
<ul>
<li><p>联想存储（？）</p>
<p>每个寄存器：一个键和一个值</p>
<p>并行搜索（高速）<br>昂贵，通常8〜2048个条目<br>地址翻译（A’，A’’）<br>如果A’在关联寄存器中，请取出帧号<br>否则从内存中的页表中获取帧号</p>
</li>
</ul>
<h4 id="具有TLB的基本分页硬件"><a href="#具有TLB的基本分页硬件" class="headerlink" title="具有TLB的基本分页硬件"></a>具有TLB的基本分页硬件</h4><p>书上（加粗）：</p>
<p><strong>TLB：转换表缓冲区。是关联的高速内存。</strong></p>
<p><strong>TLB条目由两部分组成：键（标签）和值。</strong></p>
<p><strong>当关联内存根据给定值查找时，它会同时与所有的键进行比较，如果找到条目那么就得到相应值的字段。搜索速度很快。</strong></p>
<p><strong>TLB与页表一起使用的方法：TLB只包含少数的页表条目。当CPU产生一个逻辑地址后，它的页码就发送到TLB。如果找到这个页码，那么它的帧码就立即可用，可用于访问内存。如果页码不在TLB中那么就需要访问页表。这取决于CPU，这可能由硬件自动处理或者通过操作系统的中断来处理。得到帧码后就可以用它来访问内存。另外，将页码和帧码添加到TLB中，这样下次再用时就可以很快查找到。若TLB已经满，那么会选择一个来替换。替换策略很多，如LRU到轮转替换，到随机替换等。</strong></p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114203730628.png" alt="image-20201114203730628"></p>
<p>上下文切换？<br>切换上下文后，必须刷新TLB！</p>
<ul>
<li><p>TLB缺失（TLB缺失）</p>
<ul>
<li>如果页码不在TLB中</li>
<li>那就获取和存储</li>
</ul>
</li>
<li><p>命中率</p>
<ul>
<li><p>在关联寄存器中找到页码的次数的百分比</p>
</li>
<li><p>与关联寄存器数有关的比率</p>
</li>
</ul>
</li>
<li><p>切换上下文后会发生什么？</p>
</li>
<li><p>TLB替换算法</p>
</li>
</ul>
<h4 id="有效访问时间"><a href="#有效访问时间" class="headerlink" title="有效访问时间"></a>有效访问时间</h4><ul>
<li>如果<br>关联查询 = ϵ时间单位<br>假设存储周期时间为t微秒<br>命中率= x<br>有效访问时间（EAT）=（t + ϵ）x +（2t + ϵ）（1-x）= 2t + ϵ-tx<br>如果ϵ = 20ns，t = 100ns，x1 = 80％，x2 = 98％：<br>如果TLB命中：20 + 100 = 120ns<br>如果TLB未命中：20 + 100 + 100 = 220ns<br>EAT1 = 120 * 0.8+ 220 * 0.2 = 140ns<br>EAT2 = 120 * 0.98 + 220 * 0.02 = 122ns</li>
</ul>
<h3 id="8-5-3保护"><a href="#8-5-3保护" class="headerlink" title="8.5.3保护"></a>8.5.3保护</h3><ul>
<li><p>通过将保护位与每个帧相关联来实现内存保护</p>
<ul>
<li><p>提供只读，读写，仅执行保护或…</p>
</li>
<li><p>附加到页表中每个条目的有效无效位：<br>“有效”表示关联页面在流程逻辑地址空间中，因此是合法页面<br>“无效”表示该页面不在进程逻辑地址空间中</p>
</li>
</ul>
</li>
<li><p>示例：页表中的有效（v）或无效（i）位<br>地址空间2的14次方（0~16383），<br>页的大小2KB；<br>进程大小（0〜10468）<br>第5页有内部碎片<br>PTLR = 6，第6和7页是不合法的</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115105406904.png" alt="image-20201115105406904"></p>
<p>一个进程很少会使用它的所有地址空间。</p>
<h3 id="8-5-4共享页"><a href="#8-5-4共享页" class="headerlink" title="8.5.4共享页"></a>8.5.4共享页</h3><ul>
<li><p>分页的优点之一是可以共享公共代码。对于分时环境这种考虑特别重要</p>
</li>
<li><p>共享代码</p>
<ul>
<li>进程（即文本编辑器，编译器，窗口系统）之间共享的只读（可重入或可重入）代码的副本。</li>
<li>共享代码必须出现在所有进程的逻辑地址空间中的同一位置。</li>
<li>在执行期间永远不能更改。</li>
</ul>
</li>
<li><p>私人密码和数据</p>
<ul>
<li>每个过程都保留代码和数据的单独副本。</li>
<li>专用代码和数据的页面可以出现在逻辑地址空间中的任何位置。</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115110415035.png" alt="image-20201115110415035"></p>
<h2 id="8-6页表结构"><a href="#8-6页表结构" class="headerlink" title="8.6页表结构"></a>8.6页表结构</h2><h3 id="8-6-1分层分页"><a href="#8-6-1分层分页" class="headerlink" title="8.6.1分层分页"></a>8.6.1分层分页</h3><ul>
<li>将逻辑地址空间（LAS）分解为多个页表<ul>
<li>需要索引</li>
<li>一种简单的技术是两级页表</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115110614122.png" alt="image-20201115110614122"></p>
<h4 id="双层分页策略"><a href="#双层分页策略" class="headerlink" title="双层分页策略"></a>双层分页策略</h4><ul>
<li><p>如果在页面大小为4K的32位计算机上，逻辑地址分为</p>
<ul>
<li><p>20位页码和12位页面偏移量</p>
</li>
<li><p>由于页表已被分页，因此页码进一步分为：<br>一个10位页码和10位页偏移<br>因此，逻辑地址分为如下形式：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115121847380.png" alt="image-20201115121847380"></p>
</li>
<li><p>其中p1是用来访问外部页表的索引，p2是内部页表的页偏移。</p>
</li>
</ul>
</li>
</ul>
<p>例子：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115121906320.png" alt="image-20201115121906320"></p>
<p>地址翻译方案：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115121923949.png" alt="image-20201115121923949"></p>
<p>双层分页方案：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115121947561.png" alt="image-20201115121947561"></p>
<p>三层分页方案：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115122003770.png" alt="image-20201115122003770"></p>
<h3 id="8-6-2哈希页表"><a href="#8-6-2哈希页表" class="headerlink" title="8.6.2哈希页表"></a>8.6.2哈希页表</h3><p>处理大于32位地址空间的常用方法是使用哈希页表，采用虚拟页码作为哈希值。</p>
<ul>
<li><p>常见于地址空间&gt; 32位</p>
</li>
<li><p>哈希表的每一个条目都包括一个链表，该链表的元素哈希到同一位置（该链表用来解决碰撞）</p>
</li>
<li><p>每个元素由三个字段组成：</p>
<ul>
<li><p>虚拟页码</p>
</li>
<li><p>映射的帧码</p>
</li>
<li><p>指向链表内下一个元素的指针</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>算法工作如下：</li>
<li>虚拟地址的虚拟页码哈希到哈希表（此页表包含一连串散列到相同位置的元素）</li>
<li>用虚拟页码与链表内第一个元素的第一个字段相比较，如果匹配，那么相应的帧码（第二个字段）就用来形成物理地址，如果不匹配，那么与链表内的后序节点的第一个字段进行比较，以查找匹配的页码</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115123323834.png" alt="image-20201115123323834"></p>
<h3 id="8-6-3倒置页表"><a href="#8-6-3倒置页表" class="headerlink" title="8.6.3倒置页表"></a>8.6.3倒置页表</h3><ul>
<li>对于每个真正的内存页或帧，倒置页表才有一个条目<ul>
<li>每个条目包含保存在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息。</li>
</ul>
</li>
</ul>
<ul>
<li><p>好处</p>
<ul>
<li><p>减少存储每个页表所需的内存（每个物理内存的页只有一条相应的条目）</p>
</li>
<li><p>系统中只有一页表</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p> 发生页面引用时增加了搜索表所需的时间</p>
</li>
<li><p>使用哈希表将搜索限制为一个或最多几个page表条目</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115123617499.png" alt="image-20201115123617499"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟内存管理</title>
    <url>/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="第九章-虚拟内存管理"><a href="#第九章-虚拟内存管理" class="headerlink" title="第九章 虚拟内存管理"></a>第九章 虚拟内存管理</h1><h2 id="9-1背景"><a href="#9-1背景" class="headerlink" title="9.1背景"></a>9.1背景</h2><a id="more"></a>

<ul>
<li><p><strong>虚拟内存</strong>将用户逻辑内存与物理内存分开，虚拟内存使得编程更容易</p>
</li>
<li><p><strong>虚拟地址空间</strong>就是进程如何在内存中存放的逻辑，通常进程从某一逻辑地址开始，连续存放：</p>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201120204337532.png" alt="image-20201120204337532"></p>
<ul>
<li>根据第八章所述，物理地址可以按帧来组织，并且分配给进程的物理帧也可以不连续。从而需要内存管理单元（MMU）将逻辑页映射到内存的物理页帧。</li>
</ul>
<p>虚拟内存大于物理内存的图例：</p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201120204540568.png" alt="image-20201120204540568"></p>
<h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><ul>
<li><p>多次性：最重要的特征<br>一个作业被分成多次装入内存运行</p>
</li>
<li><p>对换性<br>允许在进程运行的过程中，（部分）换入换出</p>
</li>
<li><p>虚拟性<br>逻辑上的扩充</p>
</li>
<li><p>虚拟性是以多次性和对换性为基础的。</p>
</li>
<li><p>多次性和对换性是建立在离散分配的基础上的</p>
</li>
</ul>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><h4 id="加粗为书上：（以下大部分为书上与PPT相结合并做必要修改）"><a href="#加粗为书上：（以下大部分为书上与PPT相结合并做必要修改）" class="headerlink" title="加粗为书上：（以下大部分为书上与PPT相结合并做必要修改）"></a>加粗为书上：（以下大部分为书上与PPT相结合并做必要修改）</h4><p><strong>虚拟内存允许文件和内存通过共享页而为多个进程所共享，带来以下好处：</strong></p>
<ul>
<li><strong>通过将共享对象映射到虚拟地址空间中，系统库可以为多个进程所共享。</strong></li>
<li><strong>类似的，虚拟内存允许进程共享内存。</strong></li>
<li><strong>当通过系统调用创建进程时，可以共享页面，从而加快进程创建。</strong></li>
</ul>
<h4 id="PPT："><a href="#PPT：" class="headerlink" title="PPT："></a>PPT：</h4><ul>
<li><p>一些好处：</p>
</li>
<li><p>共享内存</p>
</li>
<li><p>加快流程创建</p>
</li>
<li><p>程序员无需关心内存限制</p>
</li>
<li><p>可以同时运行更多程序</p>
</li>
<li><p>所需的I / O更少，每个用户程序将运行得更快</p>
</li>
<li><p>共享库使用</p>
</li>
<li><p>虚拟内存</p>
</li>
</ul>
<h2 id="9-2请求调页"><a href="#9-2请求调页" class="headerlink" title="9.2请求调页"></a>9.2请求调页</h2><ul>
<li><p>仅在需要时才加载页面——请求调页，常用于虚拟内存系统</p>
<ul>
<li>所需的I / O更少</li>
<li>需要更少的内存</li>
<li>更快的反应</li>
<li>更多用户</li>
</ul>
</li>
<li><p>当一个页面被需要时才指向它（？）如果是不合法的指代则抛弃，如果未在内存中，则在内存中加载之。</p>
</li>
</ul>
<p><strong>交换器 VS 调页程序</strong></p>
<ul>
<li>交换器可操纵整个过程</li>
<li>惰性交换器<ul>
<li>除非需要页面，否则切勿将页面交换到内存中</li>
<li>处理单个页面的交换器是寻呼机<img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201120210259800.png" alt="image-20201120210259800"></li>
</ul>
</li>
</ul>
<h3 id="9-2-1基本概念"><a href="#9-2-1基本概念" class="headerlink" title="9.2.1基本概念"></a>9.2.1基本概念</h3><ul>
<li>修改后的页表机制</li>
<li>缺页故障/缺页错误</li>
<li>地址翻译</li>
<li>辅助内存（作为交换空间）</li>
</ul>
<h4 id="修改后的页表机制"><a href="#修改后的页表机制" class="headerlink" title="修改后的页表机制"></a>修改后的页表机制</h4><ul>
<li><p>有效无效位（PRESENT位）</p>
<ul>
<li><p>每个页表条目都与一个有效-无效位相关联<br>v ⇒ 在内存中并且合法，<br>i ⇒ 不在内存中</p>
</li>
<li><p>开始时，将有效-无效位全部设置为i<br>在地址转换期间，如果页表项中的有效无效位是i⇒页面错误</p>
</li>
</ul>
</li>
<li><p>参考位（用于寻呼机输出）</p>
</li>
<li><p>修改位（或脏位）</p>
</li>
<li><p>辅助存储信息（用于分页器）</p>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121134918903.png" alt="image-20201121134918903"></p>
<h4 id="缺页故障（错误）"><a href="#缺页故障（错误）" class="headerlink" title="缺页故障（错误）"></a>缺页故障（错误）</h4><p><strong>对标记为无效的页面访问会产生缺页错误。分页硬件在通过页表转换地址时会注意到无效位被设置，从而陷入操作系统。这种陷阱是操作系统未能将所需的页面调入内存引起的。</strong></p>
<ul>
<li>第一次引用页面将捕获到OS：<br>页面错误（缺页故障/异常/中断）</li>
<li>缺页异常<ul>
<li>精确异常（陷阱）<br>在完全相同的位置和状态下重新启动该过程。<br>重新执行触发陷阱的指令</li>
</ul>
</li>
<li>执行一条指令可能会导致多页错误</li>
<li>页面错误可能在每个内存引用处发生</li>
<li>一条指令在获取指令或读/写操作符时可能导致多页错误</li>
</ul>
<h4 id="缺页故障（错误）处理方式："><a href="#缺页故障（错误）处理方式：" class="headerlink" title="缺页故障（错误）处理方式："></a>缺页故障（错误）处理方式：</h4><ul>
<li>操作系统查看内部表来决定：<br>如果是无效的参考 ⇒ 中止<br>如果只是不在内存中 ⇒ 带到内存中</li>
<li>找到一个空闲帧（例如从空闲帧链表上得到一个）    </li>
<li>调度一个磁盘操作，以将所需页面读到刚分配的帧</li>
<li>修改内部表并设置验证位 = v</li>
<li>重新启动被陷阱中断的指令</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121140141132.png" alt="image-20201121140141132"></p>
<p>上图：缺页错误处理图示</p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121140306794.png" alt="image-20201121140306794"></p>
<p><strong>纯请求调页：只有在需要时才将页面调入内存。</strong></p>
<p><strong>支持请求调页的硬件与分页和交换的硬件相同：</strong></p>
<p><strong>页表：能通过有效-无效位或保护位的特定值将条目标记为无效</strong></p>
<p><strong>外存（辅助存储）：用于保护不在内存（主存）中的那些页面。</strong></p>
<p><strong>请求调页的关键要求是在缺页错误后重新启动任何指令的能力。因为当发生缺页错误时，保存了被中断的进程状态（寄存器，条件代码，指令计数器），所以应能够在完全相同的状态下重新启动进程，只不过现在所需的页面已在内存中并且是可以访问的。</strong></p>
<ul>
<li><p>重新启动指令<br>C = A + B</p>
<ul>
<li>1.取指令</li>
<li>2.取得A</li>
<li>3.取得B</li>
<li>4.添加A和B</li>
<li>5.将总和存储在C中（C不在内存中）</li>
</ul>
</li>
<li><p>问题可以忽略</p>
<ul>
<li>重复</li>
<li>1条指令导致N页错误</li>
</ul>
</li>
</ul>
<h4 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h4><p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121141402897.png" alt="image-20201121141402897"></p>
<h4 id="恢复执行"><a href="#恢复执行" class="headerlink" title="恢复执行"></a>恢复执行</h4><ul>
<li>保存现场<br>在操作系统处理页面错误之前，必须保存进程状态<pre><code>示例：记录其寄存器值，PC</code></pre>
</li>
<li>恢复现场<br>保存状态允许该过程从中断的行继续进行。</li>
<li>注意：区分以下两种情况<ul>
<li>非法引用⇒处理终止</li>
<li>页面错误⇒装入或传呼</li>
</ul>
</li>
</ul>
<h3 id="9-2-2请求调页的性能"><a href="#9-2-2请求调页的性能" class="headerlink" title="9.2.2请求调页的性能"></a>9.2.2请求调页的性能</h3><ul>
<li>令p =页面错误率（0≤p≤1）<br>   如果p = 0，则无页面错误<br>   如果p = 1，则每个参考都是故障，完全在请求调页</li>
<li>有效访问时间（EAT）<br>EAT =（1-p）× 内存访问时间+ p × 缺页错误时间<br>缺页错误时间=缺页错误开销<br>+换出页面（可选）<br>+换入页面<br>+重新启动开销</li>
</ul>
<p><strong>12个动作见书p397</strong></p>
<ul>
<li><p>例</p>
<ul>
<li><p>内存访问时间= 200ns</p>
</li>
<li><p>平均页面错误服务时间= 8毫秒<br>EAT =（1-p）× 200 + p × 8ms =（1-p）× 200 + p × 8000000 = 200 + p×7999800</p>
</li>
<li><p>如果千分之一访问导致页面错误，则<br>p = 0.001<br>EAT = 8，199.8ns =8.2μs<br>这是8.2us / 200ns = 40倍的减速！！</p>
</li>
<li><p>如果我们希望性能下降&lt;10％，则<br>进餐= 200 + p×7，999，800 &lt;200（1 + 10％）= 220<br>p×7，999，800 &lt;20<br>p &lt;20 /7,999,800≈0.0000025</p>
</li>
</ul>
</li>
</ul>
<h4 id="提高性能的方法"><a href="#提高性能的方法" class="headerlink" title="提高性能的方法"></a>提高性能的方法</h4><ul>
<li>减少故障时间<br>-交换空间，快于文件系统<br>-仅脏页被换出，或<br>-仅从交换空间进行请求分页，或者<br>-最初要求从文件系统分页，换出到交换空间，然后从交换空间进行所有后续分页</li>
<li>保持极低的故障率<br>-程序执行本地化<br>-时间，空间</li>
</ul>
<h2 id="9-3写时复制"><a href="#9-3写时复制" class="headerlink" title="9.3写时复制"></a>9.3写时复制</h2><p><strong>虚拟内存在流程创建期间具有其他好处：</strong></p>
<ul>
<li>写时复制</li>
<li>允许父进程和子进程最初共享内存中的相同页面</li>
<li>如果任一进程修改了共享页面，则会创建共享页面的副本</li>
<li>COW允许更有效的流程创建，因为仅复制修改的页面</li>
<li>从清零页面池中分配免费页面</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121144049828.png" alt="image-20201121144049828"></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121144058267.png" alt="image-20201121144058267"></p>
<h2 id="9-4页面置换"><a href="#9-4页面置换" class="headerlink" title="9.4页面置换"></a>9.4页面置换</h2><ul>
<li>如果具有10页的进程只使用其中的一半，那么请求调页就节省了用来加载从不使用的另外5页的I/O。另外，通过运行两倍的进程，增加了多道程度，因此若有40帧那么可以运行8个进程而不是4个。</li>
<li>增加多道程度可能会导致过度分配内存，如果运行6个进程每个进程有10个页面但是仅仅使用5个，会有更高的CPU利用率和吞吐量。</li>
<li>而且还需要考虑到内存不仅用于保存程序页面，还有I/O缓存</li>
</ul>
<p>内存过度分配：用户进程执行–&gt;缺页错误–&gt;操作系统确定所需页面的磁盘位置却发现空闲帧列表上没有空闲帧—&gt;页面置换</p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121160704219.png" alt="image-20201121160704219"></p>
<p><strong>页面置换</strong><br>通过修改页面故障服务例程以包括页面替换，防止内存的过度分配。</p>
<h3 id="9-4-1基本页面置换"><a href="#9-4-1基本页面置换" class="headerlink" title="9.4.1基本页面置换"></a>9.4.1基本页面置换</h3><ul>
<li><p><strong>在磁盘上找到所需页面的位置</strong></p>
</li>
<li><p><strong>找到一个空闲帧：</strong></p>
<ul>
<li><p><strong>如果有空闲帧，那么就使用它</strong></p>
</li>
<li><p><strong>如果没有空闲帧，那么就使用页面置换算法来选择一个牺牲帧</strong></p>
</li>
<li><p><strong>将牺牲帧的内容写到磁盘上，修改对应的页表和帧表</strong></p>
</li>
</ul>
</li>
<li><p><strong>将所需页面读入新的空闲帧，修改页表和帧表</strong></p>
</li>
<li><p><strong>从发生缺页错误位置，继续用户进程</strong></p>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121161304859.png" alt="image-20201121161304859"></p>
<p><strong>（若无空闲帧，那么需要两个页面传输（调出和调入）。这种情况实际上加倍了缺页错误的处理时间，并相应的增加了有效访问时间）</strong></p>
<ul>
<li>没有修改，就没有写入（到磁盘/交换空间）<ul>
<li>使用修改（脏）位来减少页面传输的开销<br>-仅将修改的页面写入磁盘</li>
<li>此技术也适用于只读页面<br>-例如，二进制代码页</li>
</ul>
</li>
<li><strong>页面置换是请求调页的基础。它完成了逻辑内存和物理内存之间的分离</strong><ul>
<li>可以在较小的物理内存上提供大的虚拟内存</li>
</ul>
</li>
<li>按需分页，获得最低的页面错误率，两个主要问题<ul>
<li>帧分配算法——<strong>若有多个进程在内存中，则必须选择要为每个进程分配多少帧</strong></li>
<li>页面置换算法——<strong>当需要页面置换时，必须选择要置换的帧</strong></li>
</ul>
</li>
</ul>
<p><strong>有许多页面置换算法，每个操作系统可能都有自己的置换方案。通常采用最小缺页错误率的算法。</strong></p>
<ul>
<li>目标：获得最低的页面错误率</li>
<li>通过在特定的内存引用字符串（引用字符串）上运行并计算该字符串上的页面错误数来评估不同的算法</li>
<li>引用字符串是程序引用的地址序列<br>例：<ul>
<li>地址参考字符串：<br>0100 0432 0101 0612 0102 0103 0104 0101 0611 0103 0104 0101 0610 0102 0103 0104 0101 0609 0102 0105</li>
<li>假设页面大小= 100B，则其对应的页面参考字符串为：1 4 1 6 1 6 1 6 1 6 1</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121162716728.png" alt="image-20201121162716728"></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121162727420.png" alt="image-20201121162727420"></p>
<h3 id="9-4-2FIFO页面置换"><a href="#9-4-2FIFO页面置换" class="headerlink" title="9.4.2FIFO页面置换"></a>9.4.2FIFO页面置换</h3><ul>
<li><strong>最简单的页面替换算法：FIFO</strong></li>
<li><strong>FIFO页面置换算法为每个页面记录了调到内存的时间。当必须置换页面时，将选择最旧的页面</strong></li>
<li><strong>可以创建一个FIFO队列来管理所有的内存页面（无需记录确切时间）</strong><ul>
<li><strong>置换的是队列的首个页面</strong></li>
<li><strong>当需要调入页面到内存时，就将它加到队列的尾部</strong></li>
</ul>
</li>
<li><strong>示例1：15次缺页错误，12次页面置换</strong></li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163336874.png" alt="image-20201121163336874"></p>
<p><strong>Belady异常：对于有些页面置换算法随着分配帧数量的增加缺页错误率可能会增加！</strong></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163442167.png" alt="image-20201121163442167"></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163449651.png" alt="image-20201121163449651"></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121163711889.png" alt="image-20201121163711889"></p>
<h3 id="9-4-3最优页面置换"><a href="#9-4-3最优页面置换" class="headerlink" title="9.4.3最优页面置换"></a>9.4.3最优页面置换</h3><ul>
<li><p><strong>简单地说：置换最长时间不会使用的页面。</strong></p>
</li>
<li><p><strong>由于需要引用串的未来知识，最优置换算法难以实现。</strong></p>
</li>
<li><p><strong>最优置换算法主要用于比较研究。</strong></p>
</li>
<li><p><strong>不会有Belady异常</strong></p>
</li>
</ul>
<h3 id="9-4-4LRU页面置换"><a href="#9-4-4LRU页面置换" class="headerlink" title="9.4.4LRU页面置换"></a>9.4.4LRU页面置换</h3><ul>
<li><p><strong>LRU——最近最少使用</strong></p>
</li>
<li><p><strong>是最优算法的一个近似</strong></p>
</li>
<li><p>使用最近的过去作为不久的将来的近似值</p>
</li>
<li><p>替换最长时间未使用的页面</p>
</li>
<li><p>对于每个页面：记录其最后一次使用的时间</p>
</li>
<li><p>替换：最旧的时间值</p>
</li>
</ul>
<p>示例1：12个页面错误，9个页面替换</p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121165125824.png" alt="image-20201121165125824"></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121165331407.png" alt="image-20201121165331407"></p>
<p><strong>LRU置换算法也不会有Belady异常</strong></p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121165402585.png" alt="image-20201121165402585"></p>
<p>LRU算法的实现：</p>
<ul>
<li><p><strong>计数器：</strong>每个页表条目关联一个时间域，并为CPU添加一个逻辑时钟或计数器。<strong>每次内存引用都会递增时钟。每当进行页面引用时，时钟寄存器的内容会复制到相应页面的也秒条目的使用时间域。置换具有最小时间的页面。</strong></p>
<ul>
<li>该方案需要搜索页表以查找LRU页面而且每次内存访问都要写到内存（到页表的使用时间域）。当页表更改时（由于CPU调度），还必须保留时间。时钟溢出也要考虑。</li>
</ul>
</li>
<li><p><strong>堆栈：</strong>以双链接形式保留一堆页码。</p>
<ul>
<li><p>引用页面时：将其移到顶部</p>
</li>
<li><p>（最坏情况）需要更改6个指针</p>
</li>
<li><p>每次更新都比较费时</p>
</li>
<li><p>没有寻找替代品</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201121170629101.png" alt="image-20201121170629101"></p>
<h3 id="9-4-5近似LRU页面置换"><a href="#9-4-5近似LRU页面置换" class="headerlink" title="9.4.5近似LRU页面置换"></a>9.4.5近似LRU页面置换</h3><ul>
<li><p><strong>页表内的每个条目都关联着一个引用位</strong></p>
</li>
<li><p><strong>可以通过检查引用位来确定哪些页面已被使用，哪些页面尚未使用</strong></p>
</li>
<li><p>每个页面都与一个位相关联，最初= 0</p>
</li>
<li><p>当引用页面时，该位设置为1</p>
</li>
<li><p>替换为0的那个（如果存在一个）</p>
</li>
<li><p>但是，我们不知道顺序</p>
</li>
</ul>
<h4 id="9-4-5-1额外引用位算法"><a href="#9-4-5-1额外引用位算法" class="headerlink" title="9.4.5.1额外引用位算法"></a><strong>9.4.5.1额外引用位算法</strong></h4><ul>
<li>可以为内存中的页表保存一个8位的字节</li>
<li>定时器中断定期地（如每100ms）将控制传到操作系统</li>
<li>操作系统将每个页面引用位移到其8位字节的高位，将其他位右移一位，并丢弃最低位。</li>
<li>这些8位移位寄存器包含着最近8个时间周期内的页面使用情况</li>
<li>具有11000100的历史寄存器值的页面比具有值01110111的页面更为“最近使用的”</li>
</ul>
<h4 id="9-4-5-2第二次机会算法"><a href="#9-4-5-2第二次机会算法" class="headerlink" title="9.4.5.2第二次机会算法"></a>9.4.5.2第二次机会算法</h4><ul>
<li><p>仅需1个参考位，修改后的FIFO算法</p>
</li>
<li><p>又称时钟算法</p>
<ul>
<li>首先，通过FIFO选择页面</li>
<li>如果要替换的页面（按时钟顺序）具有参考位= 0，则进行替换</li>
<li>如果要替换的页面（按时钟顺序）具有参考位= 1，则：<ul>
<li>设定参考位为0</li>
<li>将页面保留在内存中</li>
<li>按照相同规则替换下一页（按时钟顺序）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实现第二次机会算法的一种方式是采用循环队列</strong></p>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122110555185.png" alt="image-20201122110555185"></p>
<h4 id="9-4-5-3增强型第二次机会算法"><a href="#9-4-5-3增强型第二次机会算法" class="headerlink" title="9.4.5.3增强型第二次机会算法"></a>9.4.5.3增强型第二次机会算法</h4><ul>
<li><p>通过将引用位和修改位（参见9.4.1）作为有序对，可以改进二次机会算法。</p>
</li>
<li><p>4种类型：</p>
<ul>
<li>（0，0）– 最近没有使用且没有修改的页面，最佳的页面置换</li>
<li>（0，1）– 最近没有使用但修改过的页面，不太好的置换，因为在置换之前需要将页面写出</li>
<li>（1，0）– 最近使用过但没有修改的页面，可能很快再次使用</li>
<li>（1，1）– 最近使用过且修改过，可能很快再次使用，并且在置换之前需要将页面写出到磁盘</li>
</ul>
</li>
<li><p>替换非空的最低类型中的第一个页面</p>
</li>
<li><p>步骤（a）- 扫描（0，0）</p>
</li>
<li><p>步骤（b）- 扫描（0，1），并将引用位设置为0</p>
</li>
<li><p>步骤（c）- 回至步骤（a）</p>
</li>
</ul>
<p><strong>若第一位全为1则扫描一遍后将第一位置0</strong></p>
<p><strong>与时钟算法的主要区别：为那些已修改页面赋予更高级别，从而降低了所需I/O数量</strong></p>
<h3 id="9-4-6基于计数的页面置换"><a href="#9-4-6基于计数的页面置换" class="headerlink" title="9.4.6基于计数的页面置换"></a>9.4.6基于计数的页面置换</h3><p><strong>为每个页面的引用次数保存一个计数器，并且开发以下两种方案：</strong></p>
<ul>
<li><p>LFU（最不常用）算法：置换具有最少计数的页面</p>
<ul>
<li><p>问题：一个页面最初大量使用，然后从未使用，由于被大量使用，有一个大的计数，即使不再需要却仍保留在内存中</p>
</li>
<li><p>解决方案：定期将计数右移一位以降低平均使用计数</p>
</li>
</ul>
</li>
<li><p>MFU（最常用）算法：基于以下论点：具有最小计数的页面可能刚刚被引入并且尚未使用</p>
</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122113234216.png" alt="image-20201122113234216"></p>
<p><strong>MFU和LFU置换都不常用。这些算法的实现是昂贵的，并且它们不能很好地近似OPT算法</strong></p>
<h4 id="9-4-7页面缓冲算法"><a href="#9-4-7页面缓冲算法" class="headerlink" title="9.4.7页面缓冲算法"></a>9.4.7页面缓冲算法</h4><ul>
<li>系统通常保留一个空闲帧缓冲池</li>
<li>当出现缺页错误时，会像以前一样选择一个牺牲帧</li>
<li>然而，在写出牺牲帧之前，所需页面就读到来自缓冲池的空闲帧</li>
<li><strong>这种措施允许进程尽快重新启动，而无需等待写出牺牲帧</strong></li>
<li>牺牲帧以后被写出后，它被添加到空闲帧池</li>
</ul>
<h4 id="9-4-8应用程序与页面置换"><a href="#9-4-8应用程序与页面置换" class="headerlink" title="9.4.8应用程序与页面置换"></a>9.4.8应用程序与页面置换</h4><ul>
<li>有的操作系统允许特殊程序能够将磁盘分区作为逻辑块的打的数组（<strong>原始磁盘</strong>）来使用，而不需要通过文件系统的数据结构。</li>
</ul>
<h2 id="9-5帧分配"><a href="#9-5帧分配" class="headerlink" title="9.5帧分配"></a>9.5帧分配</h2><h3 id="9-5-1帧的最小数"><a href="#9-5-1帧的最小数" class="headerlink" title="9.5.1帧的最小数"></a>9.5.1帧的最小数</h3><p><strong>帧分配策略受到多方面的限制——所分配的帧不能超过可用帧的数量（除非所有页面共享），也必须分配至少数量的帧。</strong></p>
<p><strong>分配至少最小数量的帧的一个原因涉及性能。随着分配给每个进程的帧数量的减少，缺页错误率增加，从而减慢进程执行。此外，若在执行指令完成之前发生缺页错误，应重新启动指令。因此必须有足够的帧来容纳任何单个指令可以引用的所有不同的页面。</strong></p>
<p><strong>最小化帧的个数</strong></p>
<ul>
<li><p>每个过程需要最少的页面数</p>
</li>
<li><p>由ISA（指令集体系结构）确定</p>
<ul>
<li>我们必须有足够的帧来容纳任何一条指令都可以引用的所有不同页面</li>
</ul>
</li>
<li><p>示例：IBM 370<br>6页处理MOVC指令：<br>   指令为6个字节，可能跨越2页<br>   2页处理<br>   2页处理</p>
</li>
<li><p>两种主要的分配方案<br>   固定分配； 优先分配</p>
</li>
<li><p>两种页面置换算法</p>
<p><strong>全局置换</strong>和<strong>局部置换</strong></p>
</li>
</ul>
<h3 id="9-5-2分配算法"><a href="#9-5-2分配算法" class="headerlink" title="9.5.2分配算法"></a>9.5.2分配算法</h3><h4 id="平均分配"><a href="#平均分配" class="headerlink" title="平均分配"></a>平均分配</h4><p>在n个进程中分配m个帧的最容易方法是，给每个进程一个平均值，即m/n帧（忽略操作系统所需的帧）。eg：93个帧，5个进程，每个进程18帧，剩余3个可用作空闲帧缓冲池。</p>
<h4 id="比例分配"><a href="#比例分配" class="headerlink" title="比例分配"></a>比例分配</h4><p>根据每个进程大小分配可用内存</p>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122115629343.png" alt="image-20201122115629343"></p>
<h4 id="优先级分配"><a href="#优先级分配" class="headerlink" title="优先级分配"></a>优先级分配</h4><ul>
<li><p>使用优先级而非大小的比例分配方案</p>
</li>
<li><p>如果进程 Pi 产生页面错误，</p>
<ul>
<li><p>选择替换其框架之一</p>
</li>
<li><p>从优先级较低的进程中选择替换帧</p>
</li>
</ul>
</li>
</ul>
<h3 id="9-5-3全局分配与局部分配"><a href="#9-5-3全局分配与局部分配" class="headerlink" title="9.5.3全局分配与局部分配"></a>9.5.3全局分配与局部分配</h3><ul>
<li>全局置换<ul>
<li>允许一个进程从所有帧的集合中选择一个置换帧； 一个进程可以取下另一个帧</li>
<li>问题：进程无法控制其自身的页面错误率</li>
</ul>
</li>
<li>局部置换<ul>
<li>每个进程仅从自己分配的帧中选择一个帧</li>
<li>问题：由于不能使用其他进程较少使用的内存页面，可能会阻碍一个进程</li>
</ul>
</li>
</ul>
<h2 id="9-6系统抖动"><a href="#9-6系统抖动" class="headerlink" title="9.6系统抖动"></a>9.6系统抖动</h2><ul>
<li><p>如果某个进程没有“足够”的页面，则页面错误率非常高。 这将导致：</p>
<ul>
<li>低CPU利用率</li>
<li>OS认为它需要提高多道程序的程度</li>
<li>另一个过程被添加到系统中，变得越来越糟！</li>
</ul>
</li>
<li><p>抖动：一个进程正在忙于换入和换出页面</p>
<ul>
<li>花费比执行更多的时间</li>
</ul>
</li>
</ul>
<p><strong>阻塞的进程大大增加，就绪的进程大大减少</strong></p>
<h3 id="9-6-1系统抖动的原因"><a href="#9-6-1系统抖动的原因" class="headerlink" title="9.6.1系统抖动的原因"></a>9.6.1系统抖动的原因</h3><p><strong>不合理的多道程序程度</strong></p>
<p><strong>如何限制抖动的影响</strong></p>
<ul>
<li><p>局部置换算法？ 尚未完全解决。</p>
</li>
<li><p><strong>为了防止抖动，应为进程提供足够多的所需帧数。</strong></p>
</li>
<li><p>我们如何知道需要多少帧？</p>
</li>
<li><p><strong>工作集策略研究一个进程实际使用多少帧。这种方法定义了进程执行的局部性模型。</strong></p>
</li>
</ul>
<p><strong>局部性模型：这就是需求分页有效的原因</strong></p>
<ul>
<li>流程从一个地方迁移到另一个地方</li>
<li>地点可能重叠</li>
</ul>
<p><strong>为什么会发生抖动？</strong></p>
<ul>
<li>本地大小&gt;总内存大小<br>激活页面&gt;分配的框架</li>
</ul>
<h3 id="9-6-2工作集模型"><a href="#9-6-2工作集模型" class="headerlink" title="9.6.2工作集模型"></a>9.6.2工作集模型</h3><ul>
<li><strong>工作集模型是基于局部性假设的</strong></li>
<li><strong>采用参数</strong><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122145251540.png" alt="image-20201122145251540"><strong>定义工作集窗口（一下简称delta）</strong></li>
<li><strong>它的思想是检查最近delta个页面引用</strong></li>
<li><strong>这最近delta个页面引用的页面集合称为工作集</strong></li>
<li><strong>如果一个页面处于活动使用状态，那么它处在工作集中</strong></li>
<li><strong>如果它不再使用，那么它在最后一次引用的delta时间单位后，会从工作集中删除。</strong></li>
<li><strong>因此，工作集是程序局部的近似</strong></li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122145733309.png" alt="image-20201122145733309"></p>
<ul>
<li><p>工作集精度：<br>WSSi（Process Pi的工作集）= 最近delta中引用的总页数（随时间变化）<br>   随时间变化，取决于delta的选择</p>
<ul>
<li>如果delta太小 ⇒ 不能包含整个局部</li>
<li>如果delta太大 ⇒ 可能包含多个局部</li>
<li>如果delta = ∞ ⇒ 将涵盖整个程序</li>
</ul>
<p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122150151647.png" alt="image-20201122150151647"></p>
</li>
</ul>
<p><strong>选中了delta后，工作集模型的使用就很简单——操作系统监视每个进程的工作集，并为它分配大于其工作集的帧数。如果还有足够的额外帧，那么可启动另一进程。如果工作集大小的总和增加以至于超过可用帧的总数，则操作系统会选择一个进程来挂起，该进程的页面被写出（交换），并且其帧可以分配给其他进程。挂起的进程以后可以重启。</strong></p>
<p><strong>这种工作集策略可以防止抖动，同时保持尽可能高的多道程度，因此它优化了CPU利用率。工作集的困难是跟踪工作集</strong></p>
<p><strong>跟踪工作集</strong></p>
<ul>
<li>近似与：固定间隔计时器+引用位</li>
<li>示例：delta = 10,000<br>   每5000个时间单位后导致计时器中断<br>   每页保留两个内存位<br>   每当计时器中断时，将所有参考位的值复制并设置为0<br>   如果存储器中的一位= 1⇒工作集中的页面</li>
<li>为什么这不完全正确？<br>   在！！ 但是在哪里？<br>改善：<br>*<em>通过增加历史位的数量和中断的频率可以降低这一不不确定性，但是成本更高。**</em>10位，每1000个时间单位中断一次*</li>
</ul>
<h3 id="9-6-3缺页错误频率"><a href="#9-6-3缺页错误频率" class="headerlink" title="9.6.3缺页错误频率"></a>9.6.3缺页错误频率</h3><p>帮助控制抖动</p>
<ul>
<li>抖动具有较高的页面错误率。</li>
<li>建立“可接受的”页面错误率<ul>
<li>如果实际错误率太低，可以从进程中删除一帧</li>
<li>如果实际错误率太高，可以给进程增加一帧</li>
</ul>
</li>
</ul>
<h2 id="9-8分配内核内存"><a href="#9-8分配内核内存" class="headerlink" title="9.8分配内核内存"></a>9.8分配内核内存</h2><p><strong>内核内存</strong><br><strong>与用户内存不同</strong></p>
<ul>
<li><p>进程的逻辑（虚拟）地址空间  VS  内核地址空间</p>
<ul>
<li><p>不同的特权</p>
</li>
<li><p>是否允许页面错误？</p>
</li>
</ul>
</li>
<li><p>通常是从空闲内存池中分配</p>
<ul>
<li>内核请求存储大小不同的数据结构</li>
<li>一些内核内存可能需要物理上驻留的内存连续页面</li>
</ul>
</li>
</ul>
<h3 id="9-8-1伙伴系统"><a href="#9-8-1伙伴系统" class="headerlink" title="9.8.1伙伴系统"></a>9.8.1伙伴系统</h3><ul>
<li>从固定大小的段（由物理上连续的页面组成）分配内存</li>
<li>使用2的幂分配器分配的内存<br>以2的幂为单位满足要求<br>请求四舍五入到下一个最高幂2<br>当需要的分配量小于当前大小时，当前块被分成两个下一个较低次幂2的伙伴，直到可用的大小合适的块</li>
</ul>
<h3 id="9-8-2slab分配器"><a href="#9-8-2slab分配器" class="headerlink" title="9.8.2slab分配器"></a>9.8.2slab分配器</h3><p><img src="/2020/11/20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201122151605316.png" alt="image-20201122151605316"></p>
<ul>
<li>平板是一个或多个物理上连续的页面<br>缓存由一个或多个平板组成<br>每个唯一内核数据结构的单个缓存<br>每个缓存都填充有对象—数据结构的实例<br>创建缓存后，将其填充为标记为空闲的对象<br>存储结构时，将对象标记为已使用<br>如果slab充满了使用过的对象，则从空板<br>如果没有空板，则分配新板</li>
<li>好处：没有碎片，快速的存储请求满足</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
</search>
