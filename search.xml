<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="第八章-内存管理"><a href="#第八章-内存管理" class="headerlink" title="第八章 内存管理"></a>第八章 内存管理</h1><h2 id="8-1背景"><a href="#8-1背景" class="headerlink" title="8.1背景"></a>8.1背景</h2><h3 id="8-1-1基本硬件"><a href="#8-1-1基本硬件" class="headerlink" title="8.1.1基本硬件"></a>8.1.1基本硬件</h3><a id="more"></a>

<ul>
<li><p>高速缓存</p>
<p>将信息复制到更快的存储系统<br>访问时，请首先检查缓存，<br>如果在：直接使用<br>不在：从上层存储系统获取，并将副本保留在缓存中<br>使用缓存<br>寄存器为主存储器提供高速缓存<br>指令缓存和数据缓存<br>主内存可以视为辅助存储的快速缓存</p>
<p>必须将程序（从磁盘）带入内存并放置在进程中才能运行<br>主存储器和寄存器仅是存储CPU可以直接访问<br>一个CPU时钟（或更少）中的Registeraccess<br>主内存可能需要很多周期（几个CPU时钟）<br>缓存在主内存和CPU寄存器之间进行<br>内存的保护需要保证正确的操作</p>
</li>
<li><p>内存保护<br>基地址寄存器和界限地址寄存器定义了逻辑地址空间</p>
<ul>
<li>基地址寄存器＋界限地址寄存器</li>
<li>外部存储器受到保护</li>
<li>操作系统可以不受限制地访问显示器和用户的内存</li>
<li>只有操作系统可以通过特殊的特权指令，才能加载基地址寄存器和界限地址寄存器。</li>
</ul>
</li>
</ul>
<h3 id="8-1-2地址绑定"><a href="#8-1-2地址绑定" class="headerlink" title="8.1.2地址绑定"></a>8.1.2地址绑定</h3><ul>
<li><p>将指令和数据绑定到内存</p>
</li>
<li><p>符号地址到可重定位地址</p>
</li>
<li><p>可重定位地址到绝对地址</p>
</li>
<li><p>指令和数据到内存地址的地址绑定可以分为三个不同的阶段</p>
</li>
<li><p>通常，指令和数据绑定到存储器地址可在沿途的任何一步进行：</p>
</li>
<li><p>编译时：若编译时就已经知道程序的驻留地址，就可以生成绝对代码</p>
</li>
<li><p>如果内存位置被称为先验，则可以生成绝对代码（absolute code）；<br>如果起始位置更改，则必须重新编译代码；<br>示例：MS-DOS .COM格式程序</p>
</li>
<li><p>加载时：（可重定位代码）<br>如果在编译时不知道内存位置，则必须生成可重定位代码（可重定位代码）</p>
</li>
<li><p>执行时：</p>
<p>若进程可以在执行时从一个内存段转移到另一个内存段，那么绑定应当延迟到执行时才进行，采用这种方案需要特定硬件，大多数通用计算机操作系统采用该方法。</p>
</li>
<li><p>用户程序的多步骤处理：</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201112202116682.png" alt="image-20201112202116682"></p>
<h3 id="8-1-3逻辑地址空间与物理地址空间"><a href="#8-1-3逻辑地址空间与物理地址空间" class="headerlink" title="8.1.3逻辑地址空间与物理地址空间"></a>8.1.3逻辑地址空间与物理地址空间</h3><ul>
<li><p>CPU生成的地址通常称为逻辑地址，而内存单元看到的地址（即加载到内存地址寄存器的地址）通常称为物理地址。</p>
</li>
<li><p>编译时和加载时的地址绑定方法生成相同的逻辑地址和物理地址。但是执行时的地址绑定方案生成不同的逻辑地址和物理地址，在该情况下通常称逻辑地址为虚拟地址。由程序生成的所有逻辑地址的集合称为逻辑地址空间，这些逻辑地址对应的所有物理地址的集合称为物理地址空间。</p>
</li>
<li><p>内存管理单元（MMU）<br>将虚拟地址映射到物理地址的硬件设备<br>在MMU方案中，重定位寄存器中的值被添加到用户进程当时生成的每个地址中，然后将其发送到内存中。<br>用户程序处理逻辑地址； 它从来没有看到真正的物理地址。</p>
</li>
<li><p>使用重定位寄存器的动态重定位：</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201112202128762.png" alt="image-20201112202128762"></p>
<h3 id="8-1-4动态加载"><a href="#8-1-4动态加载" class="headerlink" title="8.1.4动态加载"></a>8.1.4动态加载</h3><p>加载的三种方式：</p>
<ul>
<li>绝对加载方式</li>
<li>可重定位装入方式</li>
<li>动态运行时装入方式</li>
</ul>
<p>绝对加载方式</p>
<p>编译：</p>
<ul>
<li>具有绝对地址的绝对代码<br>正在加载：</li>
<li>必须加载到指定地址</li>
<li>加载地址=绝对地址</li>
<li>执行：</li>
<li>逻辑地址=绝对地址</li>
<li>适用于简单的批处理系统（单道系统）</li>
</ul>
<p>可重定位装入方式</p>
<ul>
<li>通常，在编译时无法知道加载地址，而只能在加载时确定。<br>编译：</li>
<li>code带有相对地址的可重定位代码</li>
<li>正在加载：</li>
<li>执行：根据加载地址，将文件中的相对地址修改为内存中的绝对地址</li>
<li>这称为重定位（relocation）</li>
<li>静态静态重定位：</li>
<li>地址绑定在加载时完成一次，然后将不会更改</li>
<li>逻辑地址=绝对地址</li>
<li>适用于多道系统</li>
</ul>
<p>动态运行时装入方式</p>
<ul>
<li><p>基于参照性原则</p>
</li>
<li><p>将主程序加载到内存中并执行</p>
</li>
<li><p>例程不被加载，直到被调用</p>
</li>
<li><p>执行时加载：需要可重定位的链接加载器</p>
</li>
<li><p>loading加载前：可重定位代码</p>
</li>
<li><p>通话时而不是：</p>
<p>加载所需的例程，更新程序的地址表</p>
<p>并将控制权传递给新加载的例程</p>
</li>
<li><p>优点：<br>更好的内存空间利用率；<br>未使用的例程永远不会加载。</p>
</li>
<li><p>当需要大量代码来处理异常（例如错误进程）时很有用</p>
</li>
<li><p>不需要操作系统的特殊支持</p>
</li>
<li><p>用户责任是设计他们的程序利用这种方法的优点</p>
</li>
<li><p>操作系统可以通过实现动态加载的程序库来帮助程序员</p>
</li>
</ul>
<h3 id="8-1-5动态联建与共享库"><a href="#8-1-5动态联建与共享库" class="headerlink" title="8.1.5动态联建与共享库"></a>8.1.5动态联建与共享库</h3><p>链接：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201112203018298.png" alt="image-20201112203018298"></p>
<p>根据链接的时间可以分为：</p>
<ul>
<li>静态链接方式</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ul>
<p>静态链接方式</p>
<ul>
<li>加载之前，所有对象模块和所需的库都链接到一个可加载的二进制程序映像中。<br>在对象模块和（静态）库中：相对地址<br>存在外部呼叫或对外部符号的引用</li>
<li>（函数或变量）：<br>对象模块←→对象模块； 对象模块→库</li>
<li>连结时<br>相对地址被修改：<br>多个相对地址空间→一个相对地址空间<br>外部调用和引用是定界的</li>
<li>这种功能通常用于系统库，如语言的子程序库。没有这种功能，系统内所有的程序都需要一份语言库的副本，这种要求浪费了磁盘空间和内存空间。</li>
<li>坏处：<br>系统上的每个程序都必须包含必需的副本<br>库（或至少必需的例程）<br>例如语言库</li>
</ul>
<p>装入时动态链接</p>
<ul>
<li><p>加载时链接：</p>
</li>
<li><p>外部调用和引用是定界的<br>根据外部调用和引用，加载<br>程序找到所需的对象模块和库，并<br>将它们加载到内存中</p>
</li>
<li><p>相对地址被修改：<br>多个相对地址空间→一个相对地址空间</p>
</li>
<li><p>优点：<br>易于修改和更新对象模块和库<br>轻松共享对象模块和库</p>
</li>
</ul>
<p>运行时动态链接</p>
<ul>
<li>每次执行时，一个程序可能不同<ul>
<li>链接推迟到执行时间</li>
</ul>
</li>
<li>链接时：<ul>
<li>每个库例程的映像中都包含一个stubis<br>参考资料</li>
<li>stubis是一小段代码，用于查找<br>适当的内存驻留库例程</li>
</ul>
</li>
<li>执行期间：<ul>
<li>存根将其自身替换为例程的地址，并且<br>执行例程</li>
<li>操作系统需要检查例程是否在进程的内存地址中<br>动态链接对于库-共享库特别有用<br>优点：加载时间短，存储空间少</li>
</ul>
</li>
</ul>
<h2 id="8-2交换"><a href="#8-2交换" class="headerlink" title="8.2交换"></a>8.2交换</h2><ul>
<li>进程必须在内存中以便执行。不过，内存可以暂时从<strong>内存</strong>交换到<strong>备份存储</strong>，当再次执行时再调回到内存中。交换有可能让所有进程的总的物理地址空间超过真实系统的物理地址空间，从而增加了系统的<strong>多道程序程度</strong>。</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201112230619494.png" alt="image-20201112230619494"></p>
<h3 id="8-2-1标准交换"><a href="#8-2-1标准交换" class="headerlink" title="8.2.1标准交换"></a>8.2.1标准交换</h3><ul>
<li><p>交换要求：<br>对换空间<br> 换出（或滚出）<br> 换入（或滚入）</p>
</li>
<li><p>备份存储：足够大的快速磁盘，可以容纳所有用户的所有内存映像副本； 必须提供对这些内存映像的直接访问</p>
<ul>
<li><p>为了加快速度，请考虑连续分配，并忽略碎片问题</p>
</li>
<li><p>需要提供数据结构来管理空闲磁盘块</p>
<ul>
<li>类似于动态分区分配</li>
</ul>
</li>
</ul>
</li>
<li><p>进程换出</p>
<ul>
<li>步骤1：选择要换出的流程</li>
<li>RR调度：<br>时间片到期时换出<br>基于优先级的调度：推出，推出<br>较低优先级的进程被换出，因此可以加载和执行较高优先级的进程。</li>
<li>步骤2：换出<br>确定要换出的内容<br>（1）不可共享的代码段和数据段<br>（2）可共享的代码和数据段：counter（计数器）<br>  在后备存储上分配空间，换出并修改相关数据结构</li>
</ul>
</li>
<li><p>进程换入</p>
<ul>
<li><p>步骤1：选择要交换的进程</p>
<p>具有静态就绪状态（静止就绪状态）的进程+其他<br>原则<br>-就绪队列：后备存储或存储中的所有就绪进程<br>记忆</p>
</li>
<li><p>步骤2：分配内存空间并交换<br>-如果有可用的内存…<br>-否则，通过换出其他进程来释放内存<br>交换时间的主要部分是传输时间； 总传输时间与所交换的内存量成正比<br>在许多系统（例如UNIX，Linux和Windows）上都可以找到修改后的交换版本</p>
</li>
</ul>
</li>
</ul>
<h2 id="8-3连续内存分配"><a href="#8-3连续内存分配" class="headerlink" title="8.3连续内存分配"></a>8.3连续内存分配</h2><h3 id="8-3-1内存保护"><a href="#8-3-1内存保护" class="headerlink" title="8.3.1内存保护"></a>8.3.1内存保护</h3><h3 id="8-3-2内存分配"><a href="#8-3-2内存分配" class="headerlink" title="8.3.2内存分配"></a>8.3.2内存分配</h3><h4 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h4><ul>
<li>每个进程都包含在内存的单个连续部分中</li>
<li>单编程内存分配（单一连续）</li>
<li>多分区分配<ul>
<li>固定分区</li>
<li>动态分区（动态分区）</li>
</ul>
</li>
</ul>
<h4 id="单一连续内存分配"><a href="#单一连续内存分配" class="headerlink" title="单一连续内存分配"></a>单一连续内存分配</h4><ul>
<li><p>最简单的方法</p>
</li>
<li><p>至多一次一个进程</p>
</li>
<li><p>主内存通常被划分为两部分：</p>
<ul>
<li>常驻OS，通常以中断向量保存在低内存中</li>
<li>然后将用户进程保存在高内存中</li>
</ul>
</li>
<li><p>内存保护策略：</p>
<p>使用MMU（动态映射逻辑地址），例如：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201112235931211.png" alt="image-20201112235931211"></p>
</li>
<li><p>或者不用任何保护</p>
</li>
</ul>
<h4 id="多分区分配"><a href="#多分区分配" class="headerlink" title="多分区分配"></a>多分区分配</h4><p>使多个用户的进程同时驻留在内存中。</p>
<ul>
<li>用户分区分为n个分区</li>
<li>每个分区可能只包含一个进程<br>1）当分区空闲时，选择输入队列中的进程并将其加载到空闲分区中<br>2）进程终止时，该分区可用于另一个进程</li>
<li>多道程序度（multiprogramming）的程度取决于分区数。</li>
</ul>
<h5 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h5><ul>
<li><p>最简单的多分区方法：IBM OS / 360（MFT）<br>-内存分为几个固定大小的分区<br>-分区大小：相等VS不相等<br>-数据结构与分配算法</p>
</li>
<li><p>缺点</p>
<ul>
<li>较差的内存使用</li>
<li>内部碎片</li>
<li>分配的内存可能会比请求的内存稍大</li>
<li>分区内部的内存，但未使用</li>
</ul>
</li>
</ul>
<h5 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h5><ul>
<li><p>洞–可用内存块</p>
</li>
<li><p>首先，所有内存都被认为是一个大洞。</p>
</li>
<li><p>当过程到达时，将搜索足够大的孔。 如果找到，则会根据需要将内存分配给进程，分区的其余内存将保持可用，以满足未来的请求。</p>
</li>
<li><p>各种大小的孔分散在整个内存中。</p>
</li>
<li><p>操作系统维护有关以下信息：</p>
</li>
<li><p>分配的分区</p>
</li>
<li><p>免费隔板（孔）</p>
</li>
<li><p>例：</p>
</li>
<li><p>可用分区表：需要额外的内存来存储表</p>
</li>
<li><p>可用分区列表：可以利用可用分区存储链接和分区信息</p>
</li>
</ul>
<h5 id="动态内存分配问题"><a href="#动态内存分配问题" class="headerlink" title="动态内存分配问题"></a>动态内存分配问题</h5><ul>
<li><p>如何从空孔列表中满足尺寸n的要求</p>
</li>
<li><p>首次适应：分配足够大的第一个孔</p>
</li>
<li><p>循环首次适应：分配足够大的下一个孔</p>
</li>
<li><p>最佳适应：分配足够大的最小孔；必须搜索整个列表，除非按尺寸排序</p>
<p>生产最小的剩余孔</p>
</li>
<li><p>最差适应（Worst-fit）：分配最大的洞； 还必须搜索整个列表</p>
<p>产生最大的剩余孔</p>
<p>在速度和存储利用率方面，最适合和最适合比最不适合</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201113111613796.png" alt="image-20201113111613796"></p>
<h5 id="动态分区方案"><a href="#动态分区方案" class="headerlink" title="动态分区方案"></a>动态分区方案</h5><ul>
<li><p>优点<br>分区的数量，位置和大小随着进程的移入和移出而动态变化。 它非常灵活，避免了由于固定分区中分区大小不正确而导致的内部碎片，并提高了内存利用率。</p>
</li>
<li><p>缺点<br>随着分配的进行，可用分区可能分散在整个内存中。<br>尽管进行了回收，但内存仍在被越来越多的碎片分割，形成了大量的外部碎片</p>
</li>
<li><p>外部碎片（External Fragmentation）<br>存在总内存空间来满足请求，但不是连续的<br>50％规则，给定N个已分配块，另外0.5 N个块</p>
</li>
</ul>
<h3 id="8-3-3碎片"><a href="#8-3-3碎片" class="headerlink" title="8.3.3碎片"></a>8.3.3碎片</h3><ul>
<li><p>通过压缩减少外部碎片</p>
<p>随机整理内存内容以将所有可用内存放在一个大块中</p>
<p>仅当重定位是动态的并且在执行时完成时才可以压缩</p>
</li>
</ul>
<h2 id="8-4分段"><a href="#8-4分段" class="headerlink" title="8.4分段"></a>8.4分段</h2><h3 id="8-4-1基本方法"><a href="#8-4-1基本方法" class="headerlink" title="8.4.1基本方法"></a>8.4.1基本方法</h3><ul>
<li><p>是支持用户查看内存的内存管理方案</p>
</li>
<li><p>程序是段的集合</p>
</li>
<li><p>段是逻辑单元，包含如下的名称和长度：<br>主程序<br>进程？<br>功能<br>方法（函数）<br>物体<br>局部变量<br>全局变量<br>普通块<br>栈<br>符号表<br>数组</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115124640582.png" alt="image-20201115124640582"></p>
<h3 id="8-4-2分段硬件"><a href="#8-4-2分段硬件" class="headerlink" title="8.4.2分段硬件"></a>8.4.2分段硬件</h3><ul>
<li><p>逻辑地址空间<br>   段的集合，每个段&lt;名称； 长度&gt;</p>
</li>
<li><p>-2-D地址空间<br>   逻辑地址由两个元组组成<br>-&lt;segname; 偏移量&gt;或<br>-&lt;segnum; 偏移量&gt;</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115124855336.png" alt="image-20201115124855336"></p>
<ul>
<li><p>逻辑地址由两个元组组成：<br>&lt;段号，偏移量&gt;</p>
</li>
<li><p>段表–将二维逻辑地址映射到一维物理地址；<br>每个表条目都有：</p>
<pre><code>base –包含段驻留在内存中的起始物理地址
限制-指定段的长度</code></pre>
</li>
<li><p>段表基址寄存器（STBR）指向段表在内存中的位置</p>
</li>
<li><p>段表长度寄存器（STLR）指示程序使用的段数；<br>如果s &lt;STLR，则段号为sis</p>
</li>
</ul>
<p><strong>分段结构：</strong></p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115125010185.png" alt="image-20201115125010185"></p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115125029588.png" alt="image-20201115125029588"></p>
<ul>
<li>例子：<br>分段<br>&lt;segment 2，53&gt;→4300 + 53 = 4353<br>&lt;segment 3，852&gt;→3200 + 852 = 4052</li>
</ul>
<h4 id="分页和分段之间的区别"><a href="#分页和分段之间的区别" class="headerlink" title="分页和分段之间的区别"></a>分页和分段之间的区别</h4><ul>
<li>动机和目的<ul>
<li>分页：   分页：面向系统，物理上离散，减少内部和内部碎片，内存实用程序↑<ul>
<li>页面是信息的物理单位   </li>
</ul>
</li>
<li>分段：面向用户，逻辑上离散，满足用户需求<ul>
<li>段是具有相对完整含义的信息的逻辑单元</li>
</ul>
</li>
</ul>
</li>
<li>大小<pre><code>分页：大小是固定的，取决于硬件
细分：大小不固定，取决于程序和</code></pre>
在编译时决定</li>
<li>维度<pre><code>分页：1-D
细分：二维，细分名称（数字）+细分偏移</code></pre>
</li>
</ul>
<h2 id="8-5分页"><a href="#8-5分页" class="headerlink" title="8.5分页"></a>8.5分页</h2><p>分段允许进程的物理地址空间是不连续的。分页是提供这种优势的另一种内存管理方案</p>
<p>进程的LAS可以是不连续的； 只要有可用的物理内存，就为进程分配物理内存</p>
<h3 id="8-5-1基本方法"><a href="#8-5-1基本方法" class="headerlink" title="8.5.1基本方法"></a>8.5.1基本方法</h3><ul>
<li><p>将物理内存分为固定大小的块，称为帧（物理页框）：大小为2的幂，512B-8,192B</p>
</li>
<li><p>页面帧号（物理页框号，PFN）：0,1，…，PFNmax</p>
</li>
<li><p>将逻辑内存划分为相同大小的块，称为页面（逻辑页，页）<br>逻辑页框号，LFN：<br>0,1，…，LFNmax</p>
</li>
<li><p>例如，逻辑地址空间现在完全独立于物理地址空间，因此，一个进程可以有一个64位的逻辑地址空间，而系统的物理内存小于2的64次方字节。</p>
</li>
<li><p><strong>由CPU生成的每个地址分为两部分：页码和页偏移。页码作为页表的索引。页表包含每页所在物理内存的基地址。这个基地址与页偏移的组合就形成了物理内存地址，可发送到物理单元。</strong></p>
</li>
<li><p>需要分页的硬件和软件支持</p>
<ul>
<li>跟踪所有空闲帧</li>
<li>要运行大小为n页的程序，需要找到n个空闲帧并加载程序</li>
<li>设置页表以将每个进程的逻辑地址转换为物理地址</li>
</ul>
</li>
<li><p>内部碎片&lt;页面大小</p>
</li>
</ul>
<h4 id="地址翻译方案"><a href="#地址翻译方案" class="headerlink" title="地址翻译方案"></a>地址翻译方案</h4><ul>
<li><p>CPU生成的地址分为：</p>
</li>
<li><p>页码（p），LFN-包含每个页的基地址的页表索引</p>
</li>
<li><p>页面偏移量（d）–与基地址结合以定义物理地址</p>
</li>
<li><p>如何获得p和d？</p>
</li>
<li><p>页码（p），LFN</p>
</li>
<li><p>页面偏移量（d）</p>
</li>
<li><p>如何获得p和d？</p>
</li>
<li><p>答：一个地址，可以是逻辑地址或物理地址<br>L：页面或页面框架的大小<br>p和d：页码的对应编号和页偏移</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114171330483.png" alt="image-20201114171330483"></p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114171439009.png" alt="image-20201114171439009"></p>
<p>分页硬件：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114171507220.png" alt="image-20201114171507220"></p>
<p>分页例子：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114171522880.png" alt="image-20201114171522880"></p>
<ul>
<li><p>如上图，逻辑的地址的n为2，m为4.采用大小为4字节而物理内存为32字节。</p>
</li>
<li><p>逻辑地址0的页码为0，页偏移为0。根据页表，可以查到页码0对应帧5，因此逻辑地址0映射到物理地址20[= (5 * 4) + 0]。逻辑地址3（页码为0，页偏移为3）映射到物理地址23[= (5 * 4) + 3]。逻辑地址4页码为1，页偏移为0；根据页表，页码为1对应帧6.因此，逻辑地址4映射到物理地址24[= (6 * 4) + 0]。逻辑地址13映射到物理地址9。</p>
</li>
</ul>
<h4 id="自由框架"><a href="#自由框架" class="headerlink" title="自由框架"></a>自由框架</h4><p>由于操作系统正在管理物理内存，因此它必须了解物理内存的分配详细信息</p>
<ul>
<li>分配哪些帧</li>
<li>哪些框架可用</li>
<li>总帧数</li>
<li>框架表：每个物理页面框架一个条目</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114201743107.png" alt="image-20201114201743107"></p>
<h3 id="8-5-2硬件支持"><a href="#8-5-2硬件支持" class="headerlink" title="8.5.2硬件支持"></a>8.5.2硬件支持</h3><ul>
<li>需要特殊的硬件（软件）来实现页表<ul>
<li>基本的分页硬件</li>
<li>带TLB的分页硬件</li>
</ul>
</li>
</ul>
<h4 id="基本的分页硬件"><a href="#基本的分页硬件" class="headerlink" title="基本的分页硬件"></a>基本的分页硬件</h4><ul>
<li><p>页表保存在主存储器中</p>
<ul>
<li><p>页表基址寄存器（PTBR）指向页表</p>
</li>
<li><p>页表长度寄存器（PRLR）指示页表的大小</p>
</li>
</ul>
</li>
<li><p>上下文切换中<br>每个进程都与页表关联。<br>页表也必须切换。</p>
</li>
<li><p>有效内存访问时间（EAT，有效访问时间）<br>-每个数据/指令访问都需要两个内存<br>访问。<br>一个用于页表<br>一种用于数据/指令。</p>
</li>
<li><p>两种内存访问问题的解决方案：<br>一种特殊的快速查找硬件缓存，称为关联存储器或转换后备缓冲器（TLB）</p>
</li>
</ul>
<p>书上：最为简单的一种方法是将页表作为一组专用的寄存器来实现，CPU分派器在加载其他寄存器时也需要加载这些寄存器。加载或修改页表寄存器的指令是特权的，因此只有操作系统可以修改内存映射表。若页表较小（256个条目）那么页表使用寄存器还是令人满意，但是当有100万个条目时，利用快速寄存器就不大可行，因此需要将页表放在内存中并将PTBR指向页表，改变页表只需改变这一个寄存器就可以，大大降低了上下文切换的时间。</p>
<ul>
<li><p>联想存储（？）</p>
<p>每个寄存器：一个键和一个值</p>
<p>并行搜索（高速）<br>昂贵，通常8〜2048个条目<br>地址翻译（A’，A’’）<br>如果A’在关联寄存器中，请取出帧号<br>否则从内存中的页表中获取帧号</p>
</li>
</ul>
<h4 id="具有TLB的基本分页硬件"><a href="#具有TLB的基本分页硬件" class="headerlink" title="具有TLB的基本分页硬件"></a>具有TLB的基本分页硬件</h4><p>书上（加粗）：</p>
<p><strong>TLB：转换表缓冲区。是关联的高速内存。</strong></p>
<p><strong>TLB条目由两部分组成：键（标签）和值。</strong></p>
<p><strong>当关联内存根据给定值查找时，它会同时与所有的键进行比较，如果找到条目那么就得到相应值的字段。搜索速度很快。</strong></p>
<p><strong>TLB与页表一起使用的方法：TLB只包含少数的页表条目。当CPU产生一个逻辑地址后，它的页码就发送到TLB。如果找到这个页码，那么它的帧码就立即可用，可用于访问内存。如果页码不在TLB中那么就需要访问页表。这取决于CPU，这可能由硬件自动处理或者通过操作系统的中断来处理。得到帧码后就可以用它来访问内存。另外，将页码和帧码添加到TLB中，这样下次再用时就可以很快查找到。若TLB已经满，那么会选择一个来替换。替换策略很多，如LRU到轮转替换，到随机替换等。</strong></p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201114203730628.png" alt="image-20201114203730628"></p>
<p>上下文切换？<br>切换上下文后，必须刷新TLB！</p>
<ul>
<li><p>TLB缺失（TLB缺失）</p>
<ul>
<li>如果页码不在TLB中</li>
<li>那就获取和存储</li>
</ul>
</li>
<li><p>命中率</p>
<ul>
<li><p>在关联寄存器中找到页码的次数的百分比</p>
</li>
<li><p>与关联寄存器数有关的比率</p>
</li>
</ul>
</li>
<li><p>切换上下文后会发生什么？</p>
</li>
<li><p>TLB替换算法</p>
</li>
</ul>
<h4 id="有效访问时间"><a href="#有效访问时间" class="headerlink" title="有效访问时间"></a>有效访问时间</h4><ul>
<li>如果<br>关联查询 = ϵ时间单位<br>假设存储周期时间为t微秒<br>命中率= x<br>有效访问时间（EAT）=（t + ϵ）x +（2t + ϵ）（1-x）= 2t + ϵ-tx<br>如果ϵ = 20ns，t = 100ns，x1 = 80％，x2 = 98％：<br>如果TLB命中：20 + 100 = 120ns<br>如果TLB未命中：20 + 100 + 100 = 220ns<br>EAT1 = 120 * 0.8+ 220 * 0.2 = 140ns<br>EAT2 = 120 * 0.98 + 220 * 0.02 = 122ns</li>
</ul>
<h3 id="8-5-3保护"><a href="#8-5-3保护" class="headerlink" title="8.5.3保护"></a>8.5.3保护</h3><ul>
<li><p>通过将保护位与每个帧相关联来实现内存保护</p>
<ul>
<li><p>提供只读，读写，仅执行保护或…</p>
</li>
<li><p>附加到页表中每个条目的有效无效位：<br>“有效”表示关联页面在流程逻辑地址空间中，因此是合法页面<br>“无效”表示该页面不在进程逻辑地址空间中</p>
</li>
</ul>
</li>
<li><p>示例：页表中的有效（v）或无效（i）位<br>地址空间2的14次方（0~16383），<br>页的大小2KB；<br>进程大小（0〜10468）<br>第5页有内部碎片<br>PTLR = 6，第6和7页是不合法的</p>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115105406904.png" alt="image-20201115105406904"></p>
<p>一个进程很少会使用它的所有地址空间。</p>
<h3 id="8-5-4共享页"><a href="#8-5-4共享页" class="headerlink" title="8.5.4共享页"></a>8.5.4共享页</h3><ul>
<li><p>分页的优点之一是可以共享公共代码。对于分时环境这种考虑特别重要</p>
</li>
<li><p>共享代码</p>
<ul>
<li>进程（即文本编辑器，编译器，窗口系统）之间共享的只读（可重入或可重入）代码的副本。</li>
<li>共享代码必须出现在所有进程的逻辑地址空间中的同一位置。</li>
<li>在执行期间永远不能更改。</li>
</ul>
</li>
<li><p>私人密码和数据</p>
<ul>
<li>每个过程都保留代码和数据的单独副本。</li>
<li>专用代码和数据的页面可以出现在逻辑地址空间中的任何位置。</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115110415035.png" alt="image-20201115110415035"></p>
<h2 id="8-6页表结构"><a href="#8-6页表结构" class="headerlink" title="8.6页表结构"></a>8.6页表结构</h2><h3 id="8-6-1分层分页"><a href="#8-6-1分层分页" class="headerlink" title="8.6.1分层分页"></a>8.6.1分层分页</h3><ul>
<li>将逻辑地址空间（LAS）分解为多个页表<ul>
<li>需要索引</li>
<li>一种简单的技术是两级页表</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115110614122.png" alt="image-20201115110614122"></p>
<h4 id="双层分页策略"><a href="#双层分页策略" class="headerlink" title="双层分页策略"></a>双层分页策略</h4><ul>
<li><p>如果在页面大小为4K的32位计算机上，逻辑地址分为</p>
<ul>
<li><p>20位页码和12位页面偏移量</p>
</li>
<li><p>由于页表已被分页，因此页码进一步分为：<br>一个10位页码和10位页偏移<br>因此，逻辑地址分为如下形式：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115121847380.png" alt="image-20201115121847380"></p>
</li>
<li><p>其中p1是用来访问外部页表的索引，p2是内部页表的页偏移。</p>
</li>
</ul>
</li>
</ul>
<p>例子：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115121906320.png" alt="image-20201115121906320"></p>
<p>地址翻译方案：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115121923949.png" alt="image-20201115121923949"></p>
<p>双层分页方案：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115121947561.png" alt="image-20201115121947561"></p>
<p>三层分页方案：</p>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115122003770.png" alt="image-20201115122003770"></p>
<h3 id="8-6-2哈希页表"><a href="#8-6-2哈希页表" class="headerlink" title="8.6.2哈希页表"></a>8.6.2哈希页表</h3><p>处理大于32位地址空间的常用方法是使用哈希页表，采用虚拟页码作为哈希值。</p>
<ul>
<li><p>常见于地址空间&gt; 32位</p>
</li>
<li><p>哈希表的每一个条目都包括一个链表，该链表的元素哈希到同一位置（该链表用来解决碰撞）</p>
</li>
<li><p>每个元素由三个字段组成：</p>
<ul>
<li><p>虚拟页码</p>
</li>
<li><p>映射的帧码</p>
</li>
<li><p>指向链表内下一个元素的指针</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>算法工作如下：</li>
<li>虚拟地址的虚拟页码哈希到哈希表（此页表包含一连串散列到相同位置的元素）</li>
<li>用虚拟页码与链表内第一个元素的第一个字段相比较，如果匹配，那么相应的帧码（第二个字段）就用来形成物理地址，如果不匹配，那么与链表内的后序节点的第一个字段进行比较，以查找匹配的页码</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115123323834.png" alt="image-20201115123323834"></p>
<h3 id="8-6-3倒置页表"><a href="#8-6-3倒置页表" class="headerlink" title="8.6.3倒置页表"></a>8.6.3倒置页表</h3><ul>
<li>对于每个真正的内存页或帧，倒置页表才有一个条目<ul>
<li>每个条目包含保存在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息。</li>
</ul>
</li>
</ul>
<ul>
<li><p>好处</p>
<ul>
<li><p>减少存储每个页表所需的内存（每个物理内存的页只有一条相应的条目）</p>
</li>
<li><p>系统中只有一页表</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p> 发生页面引用时增加了搜索表所需的时间</p>
</li>
<li><p>使用哈希表将搜索限制为一个或最多几个page表条目</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20201115123617499.png" alt="image-20201115123617499"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
</search>
